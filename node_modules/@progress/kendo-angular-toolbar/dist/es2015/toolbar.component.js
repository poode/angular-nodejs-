import { Component, HostBinding, ViewChild, ElementRef, ContentChildren, Input, ChangeDetectorRef, ViewChildren, HostListener, Output, EventEmitter, ViewContainerRef } from '@angular/core';
import { PopupService } from '@progress/kendo-angular-popup';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { RefreshService } from './refresh.service';
import { NavigationService } from './navigation.service';
import { ToolBarToolComponent } from "./tools/toolbar-tool.component";
import { outerWidth, innerWidth } from './util';
import { Keys } from './common/keys';
import { PreventableEvent } from './common/preventable-event';
import { ToolBarRendererComponent } from './renderer.component';
import { filter } from 'rxjs/operators/filter';
/**
 * Represents the [Kendo UI ToolBar component for Angular]({% slug overview_toolbar %}).
 */
export class ToolBarComponent {
    constructor(localization, popupService, refreshService, navigationService, element, cdr) {
        this.localization = localization;
        this.popupService = popupService;
        this.refreshService = refreshService;
        this.navigationService = navigationService;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */
        this.resizable = false;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the ToolBar.
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this.open = new EventEmitter();
        /**
         * @hidden
         */
        this.close = new EventEmitter();
        this._popupSettings = { animate: true };
        this.direction = localization.rtl ? 'rtl' : 'ltr';
    }
    /**
     * Configures the popup of the DropDownList.
     *
     * The available options are:
     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
     */
    set popupSettings(settings) {
        this._popupSettings = Object.assign({}, { animate: true }, settings);
    }
    get popupSettings() {
        return this._popupSettings;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    get appendTo() {
        const { appendTo } = this.popupSettings;
        if (!appendTo || appendTo === "root") {
            return undefined;
        }
        return appendTo === "component" ? this.container : appendTo;
    }
    set popupOpen(open) {
        if (this.popupOpen === open) {
            return;
        }
        const eventArgs = new PreventableEvent();
        if (open) {
            this.open.emit(eventArgs);
        }
        else {
            this.close.emit(eventArgs);
        }
        if (eventArgs.isDefaultPrevented()) {
            return;
        }
        this.toggle(open);
    }
    get popupOpen() {
        return this._open;
    }
    onFocus() {
        let focused = this.navigationService.focused;
        if (focused) {
            this.navigationService.focus(focused);
            return;
        }
        this.navigationService.focusFirst();
    }
    onKeyDown(event) {
        const prev = this.direction === "ltr" ? event.keyCode === Keys.left : event.keyCode === Keys.right;
        const next = this.direction === "ltr" ? event.keyCode === Keys.right : event.keyCode === Keys.left;
        if (prev) {
            event.preventDefault();
            this.navigationService.focusPrev();
        }
        if (next) {
            event.preventDefault();
            this.navigationService.focusNext();
        }
        if (event.keyCode === Keys.tab) {
            this.element.nativeElement.blur();
        }
        this.navigationService.keydown.emit(event);
    }
    get getTabIndex() {
        return this.tabindex;
    }
    get getRole() {
        return "toolbar";
    }
    get getDir() {
        return this.direction;
    }
    get className() {
        return "k-widget k-toolbar";
    }
    get resizableClass() {
        return this.resizable;
    }
    ngAfterViewInit() {
        if (this.resizable) {
            this.resizeSubscription = this.resizeSensor.resize
                .pipe(filter(() => this.resizable))
                .subscribe(this.onResize.bind(this));
            this.resizeSensor.resize.emit();
            this.navigationService.overflowButton = this.overflowButton;
        }
    }
    ngOnInit() {
        this.localizationChangesSubscription = this.localization
            .changes.subscribe(({ rtl }) => this.direction = rtl ? 'rtl' : 'ltr');
    }
    ngOnDestroy() {
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
        if (this.localizationChangesSubscription) {
            this.localizationChangesSubscription.unsubscribe();
        }
    }
    showPopup() {
        this.popupOpen = !this.popupOpen;
    }
    toggle(popupOpen) {
        this._open = (popupOpen !== undefined) ? popupOpen : !this.popupOpen;
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
        if (this.popupOpen) {
            this.popupRef = this.popupService.open({
                anchor: this.overflowButton,
                content: this.popupTemplate,
                appendTo: this.appendTo,
                animate: this.popupSettings.animate,
                popupClass: this.popupSettings.popupClass,
                positionMode: "absolute"
            });
            this.popupRef.popupOpen.subscribe(this.onPopupOpen.bind(this));
            this.popupRef.popupClose.subscribe(this.onPopupClose.bind(this));
            this.popupRef.popupAnchorViewportLeave.subscribe(() => this.popupOpen = false);
        }
    }
    onResize() {
        this.toggle(false);
        const containerWidth = innerWidth(this.element.nativeElement) - this.overflowAnchorWidth;
        this.shrink(containerWidth, this.childrenWidth);
        this.stretch(containerWidth, this.childrenWidth);
        this.cdr.detectChanges();
        this.resizeSensor.acceptSize();
    }
    onPopupOpen() {
        this.navigationService.moveFocusToPopup();
    }
    onPopupClose() {
        this.navigationService.moveFocusToToolBar();
    }
    get displayAnchor() {
        return this.overflowTools.length ? "visible" : "hidden";
    }
    get overflowAnchorWidth() {
        if (!this.resizable) {
            return 0;
        }
        if (!this.cachedOverflowAnchorWidth) {
            this.cachedOverflowAnchorWidth = outerWidth(this.overflowButton.nativeElement);
        }
        return this.cachedOverflowAnchorWidth;
    }
    get childrenWidth() {
        let width = 0;
        this.renderedTools.forEach((container) => {
            width += container.width;
        });
        width += this.overflowAnchorWidth;
        return Math.ceil(width);
    }
    get visibleTools() {
        return this.allTools.filter((tool) => {
            return tool.overflows === false;
        });
    }
    get overflowTools() {
        return this.allTools.filter((tool) => {
            return tool.overflows === true;
        });
    }
    shrink(containerWidth, childrenWidth) {
        let width;
        if (containerWidth < childrenWidth) {
            for (var i = this.visibleTools.length - 1; i >= 0; i--) {
                if (containerWidth > childrenWidth) {
                    break;
                }
                else {
                    width = this.hideLastVisibleTool();
                    childrenWidth -= width;
                }
            }
        }
    }
    stretch(containerWidth, childrenWidth) {
        let width;
        if (containerWidth > childrenWidth) {
            for (var i = this.overflowTools.length - 1; i >= 0; i--) {
                width = this.showFirstHiddenTool(containerWidth, childrenWidth);
                if (width) {
                    childrenWidth += width;
                }
                else {
                    break;
                }
            }
        }
    }
    hideLastVisibleTool() {
        const tool = this.visibleTools[this.visibleTools.length - 1];
        const renderedElement = this.renderedTools.find((r) => {
            return r.tool === tool;
        });
        const width = renderedElement.width;
        tool.overflows = true;
        this.refreshService.refresh(tool);
        return width;
    }
    showFirstHiddenTool(containerWidth, childrenWidth) {
        const tool = this.overflowTools[0];
        const renderedElement = this.renderedTools.find((r) => {
            return r.tool === tool;
        });
        tool.overflows = false;
        tool.visibility = "hidden";
        this.refreshService.refresh(tool);
        if (containerWidth > childrenWidth + renderedElement.width) {
            tool.visibility = "visible";
            this.refreshService.refresh(tool);
        }
        else {
            tool.overflows = true;
            this.refreshService.refresh(tool);
        }
        return renderedElement.width; //returns 0 if `overflows` is true
    }
}
ToolBarComponent.decorators = [
    { type: Component, args: [{
                exportAs: 'kendoToolBar',
                providers: [
                    RefreshService,
                    NavigationService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.toolbar'
                    }
                ],
                selector: 'kendo-toolbar',
                template: `
        <ng-container *ngFor="let tool of allTools; let index = index;">
            <kendo-toolbar-renderer [location]="'toolbar'" [resizable]="resizable" [tool]="tool"></kendo-toolbar-renderer>
        </ng-container>
        <button #overflowButton
            tabindex="-1" *ngIf="resizable" [style.visibility]="displayAnchor" class="k-overflow-anchor k-button" (click)="showPopup()">
            <span class="k-icon k-i-more-vertical"></span>
        </button>
        <ng-template #popupTemplate>
            <ul class="k-overflow-container k-list-container k-reset">
                <ng-container *ngFor="let tool of allTools; let index = index;">
                    <kendo-toolbar-renderer [location]="'overflow'" [resizable]="resizable" [tool]="tool"></kendo-toolbar-renderer>
                </ng-container>
            </ul>
        </ng-template>
        <ng-container #container></ng-container>
        <kendo-resize-sensor *ngIf="resizable" [rateLimit]="1000" #resizeSensor></kendo-resize-sensor>
    `
            },] },
];
/** @nocollapse */
ToolBarComponent.ctorParameters = () => [
    { type: LocalizationService, },
    { type: PopupService, },
    { type: RefreshService, },
    { type: NavigationService, },
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
];
ToolBarComponent.propDecorators = {
    'resizable': [{ type: Input },],
    'popupSettings': [{ type: Input },],
    'tabindex': [{ type: Input },],
    'tabIndex': [{ type: Input, args: ["tabIndex",] },],
    'open': [{ type: Output },],
    'close': [{ type: Output },],
    'allTools': [{ type: ContentChildren, args: [ToolBarToolComponent,] },],
    'overflowButton': [{ type: ViewChild, args: ["overflowButton",] },],
    'popupTemplate': [{ type: ViewChild, args: ["popupTemplate",] },],
    'resizeSensor': [{ type: ViewChild, args: ["resizeSensor",] },],
    'container': [{ type: ViewChild, args: ["container", { read: ViewContainerRef },] },],
    'renderedTools': [{ type: ViewChildren, args: [ToolBarRendererComponent,] },],
    'onFocus': [{ type: HostListener, args: ["focus",] },],
    'onKeyDown': [{ type: HostListener, args: ["keydown", ["$event"],] },],
    'getTabIndex': [{ type: HostBinding, args: ["attr.tabindex",] },],
    'getRole': [{ type: HostBinding, args: ["attr.role",] },],
    'getDir': [{ type: HostBinding, args: ["attr.dir",] },],
    'className': [{ type: HostBinding, args: ["class",] },],
    'resizableClass': [{ type: HostBinding, args: ["class.k-toolbar-resizable",] },],
};
