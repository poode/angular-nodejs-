import { Component, Input, ViewChild, ElementRef, NgZone, Renderer2 } from '@angular/core';
import { IntlService } from '@progress/kendo-angular-intl';
import { addDays, getDate } from '@progress/kendo-date-math';
import { Subscription } from 'rxjs/Subscription';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { combineLatest } from 'rxjs/operators/combineLatest';
import { switchMap } from 'rxjs/operators/switchMap';
import { take } from 'rxjs/operators/take';
import { ViewContextService } from '../view-context.service';
import { ViewStateService } from '../view-state.service';
import { scrollbarWidth, hasScrollbar, closestInScope, hasClasses } from '../../common/dom-queries';
import { anyChanged } from '../../common/changes';
import { createResourceGroups, groupEvents } from './utils';
import { ignoreContentChild } from '../utils';
import { PDFService } from '../../pdf/pdf.service';
import { LocalizationService } from '@progress/kendo-angular-l10n';
/**
 * @hidden
 */
export class AgendaViewInternalComponent {
    constructor(viewContext, viewState, intl, renderer, element, zone, pdfService, localization) {
        this.viewContext = viewContext;
        this.viewState = viewState;
        this.intl = intl;
        this.renderer = renderer;
        this.element = element;
        this.zone = zone;
        this.pdfService = pdfService;
        this.localization = localization;
        this.tasks = new BehaviorSubject(null);
        this.groupedResources = [];
        this.spans = [];
        this.subs = new Subscription();
        this.domEvents = [];
    }
    get eventTemplateRef() {
        return this.eventTemplate || (this.schedulerEventTemplate || {}).templateRef;
    }
    get agendaTimeTemplateRef() {
        return this.agendaTimeTemplate || (this.schedulerAgendaTimeTemplate || {}).templateRef;
    }
    get agendaDateTemplateRef() {
        return this.agendaDateTemplate || (this.schedulerAgendaDateTemplate || {}).templateRef;
    }
    ngOnInit() {
        this.updateContentHeight = this.updateContentHeight.bind(this);
        this.subs.add(this.viewContext.selectedDate.subscribe(this.onSelectDate.bind(this)));
        this.subs.add(this.viewContext.action.subscribe(this.onAction.bind(this)));
        this.subs.add(this.viewContext.resize.subscribe(this.updateContentHeight));
        this.subs.add(this.viewContext.items.pipe(combineLatest(this.viewState.dateRange, (items, dateRange) => {
            this.items = items;
            this.range = dateRange;
            return this.createEventGroups();
        }))
            .subscribe((tasks) => {
            this.tasks.next(tasks);
        }));
        this.subs.add(this.viewContext.optionsChange.subscribe(this.optionsChange.bind(this)));
        const onStable = () => this.zone.onStable.pipe(take(1));
        this.subs.add(this.tasks.pipe(combineLatest(this.localization.changes), switchMap(onStable, args => args))
            .subscribe(this.updateContentHeight));
        this.subs.add(this.pdfService.createElement.subscribe(this.createPDFElement.bind(this)));
    }
    ngOnChanges(changes) {
        if (anyChanged(['selectedDateFormat', 'selectedShortDateFormat'], changes)) {
            this.viewState.notifyDateRange(this.dateRange(this.selectedDate));
        }
    }
    ngAfterViewInit() {
        if (!this.element) {
            return;
        }
        this.domEvents.push(this.renderer.listen(this.content.nativeElement, 'click', (e) => {
            const eventTarget = closestInScope(e.target, node => node.hasAttribute('data-task-index'), this.element.nativeElement);
            if (eventTarget && closestInScope(e.target, node => hasClasses(node, 'k-event-delete'), eventTarget)) {
                e.preventDefault();
                const index = parseInt(eventTarget.getAttribute('data-task-index'), 10);
                const groupIndex = parseInt(eventTarget.getAttribute('data-group-index'), 10);
                const group = this.groups[groupIndex];
                const task = group.tasks.itemAt(index);
                this.viewState.emitEvent('remove', { event: task.event, dataItem: task.event.dataItem });
            }
        }));
    }
    updateContentHeight() {
        const element = this.element.nativeElement;
        const parent = element.parentNode;
        let height = parent.clientHeight;
        for (let idx = 0; idx < parent.children.length; idx++) {
            const child = parent.children[idx];
            if (child !== element && !ignoreContentChild(child)) {
                height -= child.offsetHeight;
            }
        }
        const headerElement = this.headerWrap.nativeElement;
        height -= this.headerWrap ? headerElement.offsetHeight : 0;
        const content = this.content.nativeElement;
        this.renderer.setStyle(content, 'height', `${height}px`);
        const rtl = this.localization.rtl;
        const padding = hasScrollbar(content, 'vertical') ? scrollbarWidth() : 0;
        this.renderer.setStyle(headerElement, !rtl ? 'padding-right' : 'padding-left', `${padding}px`);
        this.renderer.setStyle(headerElement, rtl ? 'padding-right' : 'padding-left', '0px');
        this.viewState.notifyLayoutEnd();
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
        this.domEvents.forEach(unbindHandler => unbindHandler());
        this.domEvents = [];
    }
    optionsChange(changes) {
        this.group = changes.group;
        this.resources = changes.resources;
        this.groupResources();
        this.min = changes.min;
        this.max = changes.max;
        this.editable = changes.editable;
        if (this.items && this.items.length) {
            this.tasks.next(this.createEventGroups());
        }
        this.schedulerEventTemplate = changes.eventTemplate;
        this.schedulerAgendaTimeTemplate = changes.agendaTimeTemplate;
        this.schedulerAgendaDateTemplate = changes.agendaDateTemplate;
    }
    onSelectDate(date) {
        this.selectedDate = date;
        this.viewState.notifyDateRange(this.dateRange());
    }
    onAction(e) {
        const now = getDate(this.selectedDate);
        if (e.type === 'next') {
            const next = getDate(addDays(now, 7));
            if (this.isInRange(next)) {
                this.viewState.notifyNextDate(next);
            }
        }
        if (e.type === 'prev') {
            const next = getDate(addDays(now, -7));
            if (this.isInRange(next)) {
                this.viewState.notifyNextDate(next);
            }
        }
    }
    createEventGroups() {
        const groups = this.groupedResources.length ? createResourceGroups(this.groupedResources) : null;
        const eventGroups = this.groups = groupEvents(this.items, this.taskResources, groups, this.spans, this.range);
        return eventGroups;
    }
    dateRange(date = this.selectedDate) {
        const start = getDate(date);
        const end = getDate(addDays(start, 7));
        const text = this.intl.format(this.selectedDateFormat, start, end);
        const shortText = this.intl.format(this.selectedShortDateFormat, start, end);
        return { start, end, text, shortText };
    }
    groupResources() {
        const resources = this.resources || [];
        const group = this.group || {};
        const grouped = group.resources;
        const groupedResources = this.groupedResources = [];
        if (grouped && grouped.length) {
            for (let groupIdx = 0; groupIdx < grouped.length; groupIdx++) {
                const name = grouped[groupIdx];
                const resource = resources.find(item => item.name === name);
                if (resource) {
                    groupedResources.push(resource);
                }
            }
        }
        this.spans = this.resourceSpans();
    }
    resourceSpans() {
        const spans = [1];
        const resources = this.groupedResources;
        let span = 1;
        for (let idx = resources.length - 1; idx > 0; idx--) {
            span *= ((resources[idx].data || []).length || 1);
            spans.unshift(span);
        }
        return spans;
    }
    get taskResources() {
        if (this.groupedResources.length) {
            return this.groupedResources;
        }
        else if (this.resources && this.resources.length) {
            return [this.resources[0]];
        }
        else {
            return [{}];
        }
    }
    isInRange(date) {
        const dateRange = this.dateRange(date);
        return (!this.min || this.min < dateRange.end) && (!this.max || dateRange.start <= this.max);
    }
    createPDFElement() {
        const element = this.element.nativeElement.cloneNode(true);
        element.style.width = `${this.element.nativeElement.offsetWidth}px`;
        element.querySelector('.k-scheduler-content').style.height = 'auto';
        const header = element.querySelector('.k-scheduler-header');
        header.style.paddingRight = 0;
        header.style.paddingLeft = 0;
        this.pdfService.elementReady.emit({
            element: element
        });
    }
}
AgendaViewInternalComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'agenda-view-internal',
                template: `
        <table class="k-scheduler-layout k-scheduler-agendaview k-scheduler-agenda">
            <tbody>
                <tr>
                    <td>
                        <div kendoSchedulerAgendaHeader [resources]="groupedResources" #headerWrap></div>
                    </td>
                </tr>
                <tr>
                    <td>
                        <div kendoSchedulerAgendaList #content
                            [editable]="editable"
                            [eventTemplate]="eventTemplateRef"
                            [agendaTimeTemplate]="agendaTimeTemplateRef"
                            [agendaDateTemplate]="agendaDateTemplateRef"
                            [tasks]="tasks | async">
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    `
            },] },
];
/** @nocollapse */
AgendaViewInternalComponent.ctorParameters = () => [
    { type: ViewContextService, },
    { type: ViewStateService, },
    { type: IntlService, },
    { type: Renderer2, },
    { type: ElementRef, },
    { type: NgZone, },
    { type: PDFService, },
    { type: LocalizationService, },
];
AgendaViewInternalComponent.propDecorators = {
    'eventTemplate': [{ type: Input },],
    'agendaTimeTemplate': [{ type: Input },],
    'agendaDateTemplate': [{ type: Input },],
    'selectedDateFormat': [{ type: Input },],
    'selectedShortDateFormat': [{ type: Input },],
    'headerWrap': [{ type: ViewChild, args: ['headerWrap', { read: ElementRef },] },],
    'content': [{ type: ViewChild, args: ['content', { read: ElementRef },] },],
};
