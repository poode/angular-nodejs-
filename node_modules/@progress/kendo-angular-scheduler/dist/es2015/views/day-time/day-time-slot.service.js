import { orderBy } from '@progress/kendo-data-query';
import { intersects, findRowIndex } from '../utils';
import { ItemMap } from '../view-items/item-map';
import { BaseSlotService } from '../view-items/base-slot.service';
import { BORDER_WIDTH } from '../constants';
import { rectContains, rectContainsX, dateInRange } from '../utils';
const EVENTS_OFFSET = 10;
function initHorizontalSlots(slots, items, rowHeight, eventHeight) {
    const padding = slots[0].padding;
    if (!items.length) {
        return {
            height: rowHeight - padding
        };
    }
    items.forEach(item => {
        item.rowIndex = undefined;
        item.rect = {
            height: eventHeight,
            width: 0
        };
    });
    const sorted = orderBy(items, [{ field: "item.startTime", dir: "asc" }, { field: "item.endTime", dir: "desc" }]);
    const slotItems = {};
    sorted.forEach(event => slots
        .filter(slot => intersects(event.item.startTime, event.item.endTime, slot.start, slot.end))
        .forEach(slot => {
        const value = slotItems[slot.key] = slotItems[slot.key] || { events: [], slot: slot };
        event.rowIndex = findRowIndex(value.events, event);
        value.events[event.rowIndex] = event;
    }));
    const top = slots[0].top;
    let maxOffset = 0;
    Object.keys(slotItems).forEach((key) => {
        const events = slotItems[key].events;
        let slotOffset = 0;
        for (let idx = 0; idx < events.length; idx++) {
            const event = events[idx];
            if (event) {
                event.rect.top = top + idx * (EVENTS_OFFSET + event.rect.height);
                slotOffset = (event.rect.top - top) + event.rect.height;
            }
        }
        maxOffset = Math.max(slotOffset, maxOffset);
    });
    maxOffset += rowHeight - padding;
    return {
        height: maxOffset,
        slotItems
    };
}
function setHorizontalOffsets(slotItems, items) {
    Object.keys(slotItems).forEach((key) => {
        const { slot, events } = slotItems[key];
        const rect = slot.rect;
        for (let idx = 0; idx < events.length; idx++) {
            const event = events[idx];
            if (event) {
                if (event.rect.left === undefined) {
                    event.rect.left = slot.rect.left;
                }
                event.rect.width += rect.width + BORDER_WIDTH;
            }
        }
    });
    items.forEach(item => {
        item.rect.width -= BORDER_WIDTH;
        item.reflow();
    });
}
const matchOverlappingRect = (left, width) => (event) => {
    const rect = event.rect;
    if (!rect) {
        return false;
    }
    const before = rect.left < left && rect.left + rect.width < left;
    const after = rect.left > left + width;
    return !before && !after;
};
/** @hidden */
export class SlotRange {
    constructor(index) {
        this.index = index;
        this.slotMap = new ItemMap();
        this.itemMap = new ItemMap();
    }
    get slots() {
        return this.slotMap.toArray();
    }
    get firstSlot() {
        return this.slotMap.first;
    }
    get lastSlot() {
        return this.slotMap.last;
    }
    get items() {
        return this.itemMap.toArray();
    }
    get rect() {
        const first = this.firstSlot.rect;
        const last = this.lastSlot.rect;
        return {
            left: first.left,
            top: first.top,
            width: last.left - first.left + last.width,
            height: last.top - first.top + last.height
        };
    }
    get start() {
        const first = this.slotMap.first;
        if (!first) {
            return null;
        }
        return first.start;
    }
    get end() {
        const last = this.slotMap.last;
        if (!last) {
            return null;
        }
        return last.end;
    }
    get hasSlots() {
        return this.slotMap.count > 0;
    }
    get hasItems() {
        return this.itemMap.count > 0;
    }
    registerItem(component) {
        this.itemMap.addItem(component.item.index, component);
    }
    unregisterItem(component, index) {
        this.itemMap.removeItem(index, component);
    }
    registerSlot(slot) {
        this.slotMap.addItem(slot.id.index, slot);
    }
    unregisterSlot(slot) {
        this.slotMap.removeItem(slot.id.index, slot);
    }
    layout() {
        const items = this.items;
        if (!items.length) {
            return;
        }
        const sorted = orderBy(items, [{ field: "item.startTime", dir: "asc" }, { field: "item.endTime", dir: "desc" }]);
        items.forEach(item => {
            item.rect = null;
        });
        const slotItems = {};
        const slots = this.slots;
        // Map each populated slot to the events in it
        sorted.forEach(event => slots
            .filter(slot => intersects(event.item.startTime, event.item.endTime, slot.start, slot.end))
            .forEach(slot => {
            const value = slotItems[slot.key] = slotItems[slot.key] || { events: [] };
            value.slot = slot;
            value.events.push(event);
        }));
        // Break slots into groups with overlapping events.
        let columns = 0;
        let groupSlots = [];
        Object.keys(slotItems).forEach(key => {
            const { slot, events } = slotItems[key];
            const count = events.length;
            columns = Math.max(count, columns);
            groupSlots.push(slot);
            const groupEnd = events.every(event => event.item.endTime <= slot.end);
            if (groupEnd) {
                groupSlots.forEach(item => item.columns = columns);
                groupSlots = [];
                columns = 0;
            }
        });
        // The maximum number of overlapping events in the group is used to create the same number of columns.
        groupSlots.forEach(slot => slot.columns = columns);
        // Compute the event width by dividing the available space in columns.
        // The last event to the right is expanded to fill the remaining space.
        const eventWidths = {};
        Object.keys(slotItems).forEach(key => {
            const { slot, events } = slotItems[key];
            const count = events.length;
            let taken = 0;
            events.forEach((event, index) => {
                const id = event.item.index;
                const last = index === count - 1;
                let size = eventWidths[id] || 1;
                if (last) {
                    size = Math.min(1 - taken, size);
                }
                else {
                    size = Math.min(1 / slot.columns, size);
                    taken += size;
                }
                eventWidths[id] = size;
            });
        });
        // Locate an available column for each event in the group,
        // starting from the top and moving down.
        Object.keys(slotItems).forEach((key) => {
            const { slot, events } = slotItems[key];
            const count = events.length;
            const fill = 0.9;
            const spacing = 2;
            const startOffset = 2;
            const slotRect = slot.rect;
            const slotLeft = slotRect.left;
            const slotWidth = slotRect.width * fill - (count - 1) * spacing - startOffset;
            const origin = slotLeft + startOffset;
            events.forEach(event => {
                const id = event.item.index;
                let width = Math.floor(eventWidths[id] * slotWidth);
                if (!event.rect) {
                    let left = origin;
                    let overlaps = events.find(matchOverlappingRect(left, width));
                    if (overlaps && overlaps.rect.left > origin) {
                        // First column is empty, adjust to fit in it.
                        width = overlaps.rect.left - slotLeft - 2 * spacing;
                    }
                    else {
                        while (overlaps) {
                            left = overlaps.rect.left + overlaps.rect.width + spacing;
                            overlaps = events.find(matchOverlappingRect(left, width));
                        }
                    }
                    event.rect = {
                        top: slotRect.top,
                        left,
                        width
                    };
                    event.origin = {
                        left: slotLeft,
                        right: slotLeft + slotRect.width
                    };
                }
                // Expand the event to the last group slot
                event.rect.height = slotRect.top + slotRect.height - event.rect.top;
            });
        });
        sorted.forEach(event => event.reflow());
    }
    initDaySlots(rowHeight, eventHeight) {
        const slots = this.slots;
        if (!slots.length) {
            return;
        }
        const { height, slotItems } = initHorizontalSlots(slots, this.items, rowHeight, eventHeight);
        this.setSlotsHeight(height);
        this.slotItems = slotItems;
    }
    setDayOffsets() {
        if (!this.itemMap.count || !this.slotItems) {
            return;
        }
        setHorizontalOffsets(this.slotItems, this.items);
        this.slotItems = null;
    }
    setSlotsHeight(height) {
        this.firstSlot.height = height;
    }
}
/**
 * @hidden
 */
export class DayTimeResourceGroup {
    constructor(index) {
        this.index = index;
        this.dayRanges = [];
        this.timeRanges = [];
    }
    registerSlot(slot) {
        const range = this.slotRange(slot);
        range.registerSlot(slot);
    }
    unregisterSlot(slot) {
        const range = this.slotRange(slot);
        range.unregisterSlot(slot);
        if (!range.hasSlots) {
            const ranges = this.slotRanges(slot);
            delete ranges[slot.id.rangeIndex];
        }
    }
    registerItem(component) {
        const range = this.itemRange(component);
        if (range) {
            range.registerItem(component);
            component.rangeIndex = range.index;
        }
        else {
            component.rangeIndex = undefined;
            component.toggle(false);
        }
    }
    unregisterItem(component, index) {
        if (component.rangeIndex !== undefined) {
            const ranges = component.item.isAllDay ? this.dayRanges : this.timeRanges;
            if (ranges[component.rangeIndex]) {
                ranges[component.rangeIndex].unregisterItem(component, index);
            }
            component.rangeIndex = undefined;
        }
    }
    forEachDateRange(callback) {
        for (let i = 0; i < this.dayRanges.length; i++) {
            callback(this.dayRanges[i]);
        }
    }
    forEachTimeRange(callback) {
        for (let i = 0; i < this.timeRanges.length; i++) {
            callback(this.timeRanges[i]);
        }
    }
    slotRange(slot) {
        const ranges = this.slotRanges(slot);
        const rangeIndex = slot.id.rangeIndex;
        if (!ranges[rangeIndex]) {
            ranges[rangeIndex] = new SlotRange(rangeIndex);
        }
        return ranges[rangeIndex];
    }
    slotRanges(slot) {
        return slot.isDaySlot ? this.dayRanges : this.timeRanges;
    }
    initTimeSlots(rowHeight, eventHeight) {
        const slots = this.slots;
        if (!slots.length) {
            return;
        }
        const { height, slotItems } = initHorizontalSlots(slots, this.items, rowHeight, eventHeight);
        this.setSlotsHeight(height);
        this.slotItems = slotItems;
    }
    setTimelineOffsets() {
        const items = this.items;
        if (!this.slotItems || !items.length) {
            return;
        }
        setHorizontalOffsets(this.slotItems, items);
        this.slotItems = null;
    }
    setSlotsHeight(height) {
        //setting the first slot height should be sufficient
        this.timeRanges[0].setSlotsHeight(height);
    }
    get items() {
        return this.timeRanges.reduce((acc, range) => acc.concat(range.items), []);
    }
    get slots() {
        return this.timeRanges.reduce((acc, range) => acc.concat(range.slots), []);
    }
    get hasSlots() {
        return Boolean(this.dayRanges.find(range => range && range.hasSlots) || this.timeRanges.find(range => range && range.hasSlots));
    }
    itemRange(component) {
        const task = component.item;
        const ranges = task.isAllDay ? this.dayRanges : this.timeRanges;
        return ranges.find(r => intersects(task.startTime, task.endTime, r.start, r.end));
    }
}
/**
 * @hidden
 */
export class DayTimeSlotService extends BaseSlotService {
    layoutDays(eventHeight = 25) {
        this.clearEmptyGroups();
        this.groups.forEach((group) => group.forEachDateRange(range => range.slots.forEach(slot => {
            slot.element.nativeElement.style.height = '';
        })));
        const rowHeight = this.groups[0].dayRanges[0].slots[0].height;
        this.groups.forEach((group) => {
            group.forEachDateRange(range => range.initDaySlots(rowHeight, eventHeight));
        });
        this.groups.forEach((group) => {
            group.forEachDateRange(range => range.setDayOffsets());
        });
    }
    layoutTimeline(eventHeight) {
        this.clearEmptyGroups();
        this.groups.forEach((group) => group.forEachTimeRange(range => range.slots.forEach(slot => {
            slot.element.nativeElement.style.height = '';
        })));
        const rowHeight = this.groups[0].timeRanges[0].slots[0].height;
        this.groups.forEach((group) => group.initTimeSlots(rowHeight, eventHeight));
        this.groups.forEach((group) => group.setTimelineOffsets());
    }
    layoutTimes() {
        this.groups.forEach((group) => group.forEachTimeRange(range => range.layout()));
    }
    forEachDateRange(callback) {
        this.groups.forEach((group, index) => {
            callback(group.dayRanges[0], index);
        });
    }
    syncDateRanges() {
        let maxHeight = 0;
        this.groups.forEach((group) => {
            const slot = group.dayRanges[0].firstSlot;
            if (slot) {
                maxHeight = Math.max(slot.rect.height - slot.padding, maxHeight);
            }
        });
        this.groups.forEach((group) => {
            group.dayRanges[0].setSlotsHeight(maxHeight);
        });
        return maxHeight;
    }
    forEachGroup(callback) {
        this.groups.forEach(callback);
    }
    forEachSlot(callback) {
        this.groups.forEach((group) => {
            group.dayRanges.forEach(range => {
                range.slots.forEach(slot => callback(slot));
            });
            group.timeRanges.forEach(range => {
                range.slots.forEach(slot => callback(slot));
            });
        });
    }
    createGroup(index) {
        return new DayTimeResourceGroup(index);
    }
    slotByIndex(slotIndex, allDay = false) {
        const [resourceIndex, rangeIndex, index] = slotIndex.split(':').map(part => parseInt(part, 10));
        return this.groups[resourceIndex][allDay ? 'dayRanges' : 'timeRanges'][rangeIndex].slots[index];
    }
    slotByPosition(x, y, includeDayRanges) {
        let range;
        if (y < 0) {
            this.groups.find((group) => {
                range = group.dayRanges.find(r => rectContainsX(r.rect, x));
                return range;
            });
            if (range) {
                return range.slots.find(slot => rectContainsX(slot.rect, x));
            }
        }
        else {
            this.groups.find((group) => {
                if (includeDayRanges) {
                    range = group.dayRanges.find(r => rectContains(r.rect, x, y));
                }
                if (!range) {
                    range = group.timeRanges.find(r => rectContains(r.rect, x, y));
                }
                return range;
            });
            if (range) {
                return range.slots.find(slot => rectContains(slot.rect, x, y));
            }
        }
    }
    groupSlotByPosition(currentSlot, x, y) {
        const group = this.groups[currentSlot.id.resourceIndex];
        let range;
        if (currentSlot.isDaySlot) {
            range = group.dayRanges.find(r => rectContains(r.rect, x, y));
        }
        else {
            range = group.timeRanges.find(r => rectContains(r.rect, x, y));
        }
        if (range) {
            return range.slots.find(slot => rectContains(slot.rect, x, y));
        }
    }
    dragRanges(currentSlot, offset, timeRanges) {
        const start = new Date(currentSlot.start.getTime() - offset.start);
        const end = new Date(currentSlot.start.getTime() + offset.end);
        const group = this.groups[currentSlot.id.resourceIndex];
        let result;
        if (timeRanges) {
            const slotRanges = [];
            group.timeRanges.forEach(range => {
                const slots = range.slots.filter(s => intersects(start, end, s.start, s.end));
                if (slots.length) {
                    slotRanges.push(slots);
                }
            });
            const lastRange = slotRanges[slotRanges.length - 1];
            result = [slotRanges[0][0], lastRange[lastRange.length - 1]];
        }
        else {
            result = group.slotRange(currentSlot).slots.filter(s => intersects(start, end, s.start, s.end));
        }
        return {
            start,
            end,
            ranges: [result]
        };
    }
    resizeRanges(currentSlot, task, resizeStart) {
        const group = this.groups[currentSlot.id.resourceIndex];
        const ranges = task.isAllDay ? group.dayRanges : group.timeRanges;
        const result = [];
        let start, end;
        if (resizeStart) {
            start = currentSlot.start.getTime() >= task.endTime.getTime() ?
                new Date(Math.max(task.startTime.getTime(), task.endTime.getTime() - 1)) : currentSlot.start;
            end = task.startTime.getTime() === task.endTime.getTime() ? new Date(task.startTime.getTime() + 1) : task.endTime;
        }
        else {
            start = task.startTime;
            end = new Date(Math.max(currentSlot.end.getTime(), task.startTime.getTime() + 1));
        }
        ranges.forEach(range => {
            const slots = range.slots.filter(s => intersects(start, end, s.start, s.end));
            if (slots.length) {
                result.push(slots);
            }
        });
        return {
            start,
            end,
            ranges: result
        };
    }
    timePosition(date, resourceIndex, vertical) {
        const group = this.groups[resourceIndex];
        const range = group.timeRanges.find(r => dateInRange(date, r.start, r.end));
        if (!range) {
            return;
        }
        const slot = range.slots.find(s => dateInRange(date, s.start, s.end));
        if (slot) {
            const position = (vertical ? slot.height : slot.width) *
                ((date.getTime() - slot.start.getTime()) / (slot.end.getTime() - slot.start.getTime()));
            return vertical ? slot.rect.top + position : slot.rect.left + position;
        }
    }
}
