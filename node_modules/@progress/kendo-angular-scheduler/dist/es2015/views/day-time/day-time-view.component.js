import { Input, ViewChildren } from '@angular/core';
import { addDays, getDate, ZonedDate } from '@progress/kendo-date-math';
import { toInvariantTime, dateInRange, setCoordinates } from '../utils';
import { createTimeSlots } from './utils';
import { BaseView } from '../common/base-view';
import { MS_PER_MINUTE } from '../constants';
import { isChanged } from '../../common/changes';
import { isDocumentAvailable } from '../../common/util';
const getStartDate = date => getDate(date);
const getEndDate = (start, numberOfDays) => getDate(addDays(start, numberOfDays || 1));
const getNextDate = (date, count, numberOfDays) => getDate(addDays(date, numberOfDays * count));
/**
 * @hidden
 */
export class DayTimeViewComponent extends BaseView {
    constructor(changeDetector, viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization) {
        super(viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization);
        this.changeDetector = changeDetector;
        this.numberOfDays = 1;
        this.startTime = '00:00';
        this.endTime = '00:00';
        this.workDayStart = '08:00';
        this.workDayEnd = '17:00';
        this.workWeekStart = 1;
        this.workWeekEnd = 5;
        this.slotDuration = 60;
        this.slotDivisions = 2;
        this.showWorkHours = false;
        this.getStartDate = getStartDate;
        this.getEndDate = getEndDate;
        this.getNextDate = getNextDate;
        this.daySlots = [];
        this.timeSlots = [];
        this.resizeHintFormat = 't';
        this.showCurrentTime = false;
        this.verticalTime = true;
        this.updateCurrentTime = this.updateCurrentTime.bind(this);
    }
    get classNames() {
        return `k-scheduler-${this.name}view`;
    }
    get timeSlotTemplateRef() {
        return this.timeSlotTemplate || (this.schedulerTimeSlotTemplate || {}).templateRef;
    }
    get dateHeaderTemplateRef() {
        return this.dateHeaderTemplate || (this.schedulerDateHeaderTemplate || {}).templateRef;
    }
    ngOnChanges(changes) {
        if (changes.startTime || changes.endTime || changes.showWorkHours || changes.workDayStart || changes.workDayEnd ||
            changes.workWeekStart || changes.workWeekEnd || changes.slotDivisions || changes.slotDivisions) {
            this.timeSlots = this.createTimeSlots();
            this.initWorkDay();
            this.changes.next(null);
        }
        if (isChanged('currentTimeMarker', changes)) {
            this.showCurrentTime = this.enableCurrentTime();
        }
        super.ngOnChanges(changes);
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        clearTimeout(this.currentTimeTimeout);
    }
    verticalItem(leafIndex, resourceIndex) {
        const data = this.verticalResources[resourceIndex].data || [];
        const resources = this.verticalResources;
        let result = 1;
        for (let idx = resourceIndex + 1; idx < resources.length; idx++) {
            result *= ((resources[idx].data || []).length || 1);
        }
        return data[(leafIndex / result) % data.length];
    }
    optionsChange(options) {
        this.schedulerTimeSlotTemplate = options.timeSlotTemplate;
        this.schedulerDateHeaderTemplate = options.dateHeaderTemplate;
        super.optionsChange(options);
    }
    updateView() {
        super.updateView();
        this.updateCurrentTime();
    }
    enableCurrentTime() {
        if (!this.currentTimeMarker || this.currentTimeMarker.enabled === false || !this.selectedDate) {
            return false;
        }
        const dateRange = this.dateRange();
        this.currentDate = ZonedDate.fromLocalDate(new Date(), this.currentTimeMarker.localTimezone !== false ? '' : this.timezone);
        const localTime = this.currentDate.toLocalDate();
        // might further limit by checking the start and end time
        return dateInRange(localTime, dateRange.start, dateRange.end);
    }
    updateCurrentTime() {
        if (!isDocumentAvailable()) {
            return;
        }
        const enable = this.enableCurrentTime();
        if (enable !== this.showCurrentTime) {
            this.showCurrentTime = enable;
            this.changeDetector.detectChanges();
        }
        clearTimeout(this.currentTimeTimeout);
        if (enable) {
            this.zone.runOutsideAngular(() => {
                this.currentTimeTimeout = setTimeout(this.updateCurrentTime, this.currentTimeMarker.updateInterval || MS_PER_MINUTE);
            });
            this.positionCurrentTime();
        }
    }
    positionCurrentTime() {
        if (this.currentTimeElements && this.currentTimeElements.length) {
            const date = this.currentDate.toUTCDate();
            const currentTimeArrows = this.currentTimeArrows ? this.currentTimeArrows.toArray() : [];
            const arrowOffset = currentTimeArrows.length ? this.currentTimeArrowOffset() : 0;
            const arrowMid = currentTimeArrows.length ? (currentTimeArrows[0].nativeElement.offsetHeight / 2) : 4;
            const tableWidth = this.contentTable.nativeElement.clientWidth;
            const tableHeight = this.contentTable.nativeElement.clientHeight;
            const vertical = this.verticalTime;
            this.currentTimeElements.forEach((element, index) => {
                const position = this.slotService.timePosition(date, index, vertical);
                if (position !== undefined) {
                    const line = element.nativeElement;
                    if (currentTimeArrows[index]) {
                        const arrow = currentTimeArrows[index].nativeElement;
                        const origin = vertical ? arrowOffset : position - arrowMid;
                        setCoordinates(arrow, {
                            top: vertical ? position - arrowMid : arrowOffset,
                            left: origin,
                            right: origin
                        });
                    }
                    const origin = vertical ? 0 : position;
                    setCoordinates(line, {
                        top: vertical ? position : 0,
                        left: origin,
                        right: origin,
                        width: vertical ? tableWidth : 1,
                        height: vertical ? 1 : tableHeight
                    });
                }
            });
        }
    }
    bindEvents() {
        super.bindEvents();
        this.zone.runOutsideAngular(() => {
            this.domEvents.push(this.renderer.listen(this.headerWrap.nativeElement, 'click', e => {
                this.onClick(e);
                if (this.daySlots.length <= 1) {
                    return;
                }
                const daySlotIndex = e.target.getAttribute('data-dayslot-index');
                if (daySlotIndex) {
                    const slot = this.daySlots[parseInt(daySlotIndex, 10)];
                    this.zone.run(() => {
                        this.viewState.navigateTo({ viewName: 'day', date: slot.start });
                    });
                }
            }), this.renderer.listen(this.headerWrap.nativeElement, 'dblclick', this.onClick), this.renderer.listen(this.headerWrap.nativeElement, 'contextmenu', this.onClick));
        });
    }
    slotByIndex(slotIndex, args) {
        return this.slotService.slotByIndex(slotIndex, args.target.hasAttribute('data-day-slot'));
    }
    onSelectDate(date) {
        this.selectedDate = date;
        this.viewState.notifyDateRange(this.dateRange());
        this.showCurrentTime = this.enableCurrentTime();
        this.daySlots = this.createDaySlots();
    }
    onAction(e) {
        const now = getDate(this.selectedDate);
        if (e.type === 'next') {
            const next = this.getNextDate(now, 1, this.numberOfDays);
            if (this.isInRange(next)) {
                this.viewState.notifyNextDate(next);
            }
        }
        if (e.type === 'prev') {
            const next = this.getNextDate(now, -1, this.numberOfDays);
            if (this.isInRange(next)) {
                this.viewState.notifyNextDate(next);
            }
        }
    }
    dateRange(date = this.selectedDate) {
        const start = this.getStartDate(date);
        const end = this.getEndDate(start, this.numberOfDays);
        const rangeEnd = this.getEndDate(start, this.numberOfDays - 1);
        const text = this.intl.format(this.selectedDateFormat, start, rangeEnd);
        const shortText = this.intl.format(this.selectedShortDateFormat, start, rangeEnd);
        return { start, end, text, shortText };
    }
    createDaySlots() {
        let current = this.getStartDate(this.selectedDate);
        const end = this.getEndDate(current, this.numberOfDays);
        const dates = [];
        while (current < end) {
            const next = addDays(current, 1);
            dates.push({
                start: current,
                end: next
            });
            current = next;
        }
        return dates;
    }
    createTimeSlots() {
        return createTimeSlots(this.intl, {
            showWorkHours: this.showWorkHours,
            startTime: this.startTime,
            endTime: this.endTime,
            workDayStart: this.workDayStart,
            workDayEnd: this.workDayEnd,
            slotDivisions: this.slotDivisions,
            slotDuration: this.slotDuration
        });
    }
    initWorkDay() {
        const startDate = this.intl.parseDate(this.workDayStart);
        this.workDayStartTime = toInvariantTime(startDate);
        const endDate = this.intl.parseDate(this.workDayEnd);
        this.workDayEndTime = toInvariantTime(endDate);
    }
    slotByPosition(x, y) {
        return this.slotService.slotByPosition(x, y, Boolean(this.verticalResources.length));
    }
}
DayTimeViewComponent.propDecorators = {
    'timeSlotTemplate': [{ type: Input },],
    'dateHeaderTemplate': [{ type: Input },],
    'numberOfDays': [{ type: Input },],
    'startTime': [{ type: Input },],
    'endTime': [{ type: Input },],
    'workDayStart': [{ type: Input },],
    'workDayEnd': [{ type: Input },],
    'workWeekStart': [{ type: Input },],
    'workWeekEnd': [{ type: Input },],
    'slotDuration': [{ type: Input },],
    'slotDivisions': [{ type: Input },],
    'showWorkHours': [{ type: Input },],
    'getStartDate': [{ type: Input },],
    'getEndDate': [{ type: Input },],
    'getNextDate': [{ type: Input },],
    'currentTimeMarker': [{ type: Input },],
    'currentTimeElements': [{ type: ViewChildren, args: ['currentTimeMarker',] },],
    'currentTimeArrows': [{ type: ViewChildren, args: ['currentTimeArrow',] },],
};
