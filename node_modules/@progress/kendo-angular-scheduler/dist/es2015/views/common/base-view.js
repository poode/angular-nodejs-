import { ViewChild, Input } from '@angular/core';
import { toLocalDate, ZonedDate } from '@progress/kendo-date-math';
import { Subscription } from 'rxjs/Subscription';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { switchMap } from 'rxjs/operators/switchMap';
import { take } from 'rxjs/operators/take';
import { combineLatest } from 'rxjs/operators/combineLatest';
import { fromEvent } from 'rxjs/observable/fromEvent';
import { merge } from 'rxjs/observable/merge';
import { map } from 'rxjs/operators/map';
import { filter } from 'rxjs/operators/filter';
import { tap } from 'rxjs/operators/tap';
import { closestInScope, hasClasses, preventLockedScroll, scrollbarWidth, wheelDeltaY, hasScrollbar } from '../../common/dom-queries';
import { groupResources, getField, setField } from '../../common/util';
import { anyChanged } from '../../common/changes';
import { assignTasksResources, toPx, elementOffset, pointDistance, ignoreContentChild } from '../utils';
import { BORDER_WIDTH } from '../constants';
import Draggable from '@telerik/kendo-draggable';
const SCROLL_CHANGE = 15;
const MIN_DISTANCE = 60;
const SCROLL_INTERVAL = 50;
const MIN_MOVE_DISTANCE = 10;
/** @hidden */
export class BaseView {
    constructor(viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization) {
        this.viewContext = viewContext;
        this.viewState = viewState;
        this.intl = intl;
        this.slotService = slotService;
        this.zone = zone;
        this.renderer = renderer;
        this.element = element;
        this.pdfService = pdfService;
        this.localization = localization;
        this.items = new BehaviorSubject(null);
        this.horizontalResources = [];
        this.verticalResources = [];
        this.dragHints = [];
        this.resizeHints = [];
        this.getField = getField;
        this.changes = new BehaviorSubject(null);
        this.subs = new Subscription();
        this.groupedResources = [];
        this.spans = [];
        this.domEvents = [];
        this.resourcesCache = {};
        this.autoHeight = false;
        this.rtl = false;
        this.setSlotClass = this.setSlotClass.bind(this);
        this.setHintClass = this.setHintClass.bind(this);
    }
    get eventTemplateRef() {
        return this.ÐµventTemplate || (this.schedulerEventTemplate || {}).templateRef;
    }
    get groupHeaderTemplateRef() {
        return this.groupHeaderTemplate || (this.schedulerGroupHeaderTemplate || {}).templateRef;
    }
    ngOnInit() {
        const updateView = this.updateView.bind(this);
        this.resourcesByIndex = this.resourcesByIndex.bind(this);
        this.subs.add(this.viewContext.selectedDate.subscribe(this.onSelectDate.bind(this)));
        this.subs.add(this.viewContext.action.subscribe(this.onAction.bind(this)));
        this.subs.add(this.viewContext.resize.subscribe(updateView));
        this.subs.add(this.viewContext.optionsChange.subscribe(this.optionsChange.bind(this)));
        this.subs.add(this.changes.subscribe(() => {
            this.toggleElement(false);
        }));
        this.subs.add(this.viewContext.items.pipe(combineLatest(this.viewState.dateRange, this.createTasks.bind(this)))
            .subscribe((tasks) => {
            this.tasks = tasks;
            this.assignResources();
            this.onTasksChange();
        }));
        this.subs.add(this.items.pipe(combineLatest(this.changes, this.localization.changes), switchMap(this.onStable.bind(this), args => args))
            .subscribe(updateView));
        this.subs.add(this.pdfService.createElement.subscribe(this.createPDFElement.bind(this)));
    }
    ngOnChanges(changes) {
        if (anyChanged(['selectedDateFormat', 'selectedShortDateFormat'], changes)) {
            this.viewState.notifyDateRange(this.dateRange(this.selectedDate));
        }
        if (changes.eventHeight) {
            this.changes.next(null);
        }
    }
    ngAfterViewInit() {
        this.bindEvents();
        this.subs.add(this.localization.changes.subscribe(({ rtl }) => {
            const prev = this.rtl;
            this.rtl = rtl;
            if (prev !== rtl) {
                this.reflow();
            }
        }));
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
        this.domEvents.forEach(unbindHandler => unbindHandler());
        this.domEvents = [];
        if (this.draggable) {
            this.draggable.destroy();
            this.draggable = null;
        }
    }
    itemIndex(index, _) {
        return index;
    }
    resourcesByIndex(index) {
        if (!this.resourcesCache[index]) {
            const resources = this.taskResources;
            const result = [];
            let currentIndex = index;
            for (let idx = 0; idx < resources.length; idx++) {
                const data = resources[idx].data || [];
                const dataIdx = Math.floor(currentIndex / this.spans[idx]);
                result.push(data[dataIdx]);
                currentIndex -= dataIdx * this.spans[idx];
            }
            this.resourcesCache[index] = result;
        }
        return this.resourcesCache[index];
    }
    optionsChange(options) {
        this.schedulerEventTemplate = options.eventTemplate;
        this.schedulerGroupHeaderTemplate = options.groupHeaderTemplate;
        this.min = options.min;
        this.max = options.max;
        this.editable = options.editable;
        this.timezone = options.timezone;
        if (!options.changes || anyChanged(['group', 'resources'], options.changes, false)) {
            this.group = options.group;
            this.resources = options.resources;
            this.groupResources();
            this.resourcesCache = {};
            if (this.tasks && this.tasks.length) {
                this.assignResources();
                this.onTasksChange();
            }
            this.changes.next(null);
        }
    }
    toggleElement(visible) {
        if (this.element) {
            this.renderer.setStyle(this.element.nativeElement, 'display', visible ? 'block' : 'none');
        }
    }
    onStable() {
        return this.zone.onStable.asObservable().pipe(take(1));
    }
    updateView() {
        this.slotService.invalidate();
        this.toggleElement(true);
        this.reflow();
        this.viewState.notifyLayoutEnd();
    }
    assignResources() {
        assignTasksResources(this.tasks, this.taskResources, this.groupedResources.length > 0, this.spans);
    }
    bindEvents() {
        this.zone.runOutsideAngular(() => {
            if (this.times) {
                this.subs.add(merge(fromEvent(this.times.nativeElement, 'mousewheel'), fromEvent(this.times.nativeElement, 'DOMMouseScroll')).pipe(filter((event) => !event.ctrlKey), tap(preventLockedScroll(this.content.nativeElement)), map(wheelDeltaY))
                    .subscribe(x => this.content.nativeElement.scrollTop -= x));
            }
            const clickHandler = this.onClick = this.onClick.bind(this);
            this.domEvents.push(this.renderer.listen(this.content.nativeElement, 'scroll', () => {
                if (this.headerWrap) {
                    this.headerWrap.nativeElement.scrollLeft = this.content.nativeElement.scrollLeft;
                }
                if (this.times) {
                    this.times.nativeElement.scrollTop = this.content.nativeElement.scrollTop;
                }
            }), this.renderer.listen(this.content.nativeElement, 'click', clickHandler), this.renderer.listen(this.content.nativeElement, 'dblclick', clickHandler), this.renderer.listen(this.content.nativeElement, 'contextmenu', clickHandler));
            this.draggable = new Draggable({
                press: this.onPress.bind(this),
                drag: this.onDrag.bind(this),
                release: this.onRelease.bind(this)
            });
            this.draggable.bindTo(this.element.nativeElement);
        });
    }
    onPress(args) {
        const resizable = this.editable && this.editable.resize !== false;
        const draggable = this.editable && this.editable.drag !== false;
        const target = args.originalEvent.target;
        if (hasClasses(target, 'k-resize-handle')) {
            if (!resizable) {
                return;
            }
            args.originalEvent.preventDefault();
            const resizing = this.targetTask(target);
            if (this.emitEvent('resizeStart', { event: resizing.task.event, dataItem: resizing.task.event.dataItem })) {
                return;
            }
            this.resizing = resizing;
            resizing.start = resizing.task.start.toUTCDate();
            resizing.end = resizing.task.end.toUTCDate();
            if (hasClasses(target, 'k-resize-n')) {
                resizing.direction = 'n';
            }
            else if (hasClasses(target, 'k-resize-s')) {
                resizing.direction = 's';
            }
            else if (hasClasses(target, 'k-resize-w')) {
                resizing.direction = 'w';
            }
            else {
                resizing.direction = 'e';
            }
            this.initResizeContainer(target);
            const { x, y } = this.coordinatesOffset(args.pageX, args.pageY);
            resizing.slot = this.slotByPosition(x, y);
        }
        else if (draggable) {
            args.originalEvent.preventDefault();
            const task = this.targetTask(target);
            if (task) {
                this.pressLocation = { x: args.pageX, y: args.pageY };
                this.pressTarget = task;
            }
        }
    }
    onDrag(args) {
        if (this.resizing) {
            this.resize(args);
            this.scrollContainer(this.resize, args);
        }
        else {
            this.initDrag(args);
            if (this.dragging) {
                this.drag(args);
                this.scrollContainer(this.drag, args);
            }
        }
    }
    onRelease() {
        clearInterval(this.scrollInterval);
        const { resizing, dragging } = this;
        if (resizing) {
            this.emitEvent('resizeEnd', {
                event: resizing.task.event,
                dataItem: resizing.task.event.dataItem,
                start: this.convertDate(resizing.start),
                end: this.convertDate(resizing.end)
            });
            this.resizeHints = [];
        }
        if (dragging) {
            this.emitEvent('dragEnd', {
                event: dragging.task.event,
                dataItem: dragging.task.event.dataItem,
                start: this.convertDate(dragging.start),
                end: this.convertDate(dragging.end),
                resources: dragging.resources,
                isAllDay: Boolean(dragging.slot.isDaySlot)
            });
            this.pressLocation = null;
            this.pressTarget = null;
            this.dragHints = [];
        }
        if (resizing || dragging) {
            this.removeSlotClass();
            this.updateHintContainer();
            this.resizing = null;
            this.dragging = null;
        }
        this.container = null;
    }
    setHintClass(className) {
        (this.dragging || this.resizing).hintClass = className;
    }
    updateHintClass() {
        const current = this.dragging || this.resizing;
        let update = false;
        this.hints.forEach(hint => {
            if (hint.class !== current.hintClass) {
                hint.class = current.hintClass;
                update = true;
            }
        });
        if (update) {
            this.updateHintContainer();
        }
    }
    removeHintClass() {
        (this.dragging || this.resizing).hintClass = null;
    }
    setSlotClass(className) {
        const current = this.dragging || this.resizing;
        current.slotClass = className;
        this.renderer.addClass(current.slot.nativeElement, current.slotClass);
    }
    removeSlotClass() {
        const current = this.dragging || this.resizing;
        if (current.slotClass) {
            this.renderer.removeClass(current.slot.nativeElement, current.slotClass);
            current.slotClass = null;
        }
    }
    get hints() {
        return this.dragging ? this.dragHints : this.resizeHints;
    }
    initDrag(args) {
        if (!this.dragging && this.pressLocation && pointDistance(this.pressLocation.x, this.pressLocation.y, args.pageX, args.pageY) >= MIN_MOVE_DISTANCE) {
            const dragging = this.pressTarget;
            const task = dragging.task;
            if (this.emitEvent('dragStart', { event: task.event, dataItem: task.event.dataItem })) {
                this.pressLocation = null;
                this.pressTarget = null;
                return;
            }
            this.dragging = dragging;
            this.container = this.content.nativeElement;
            this.containerOffset = elementOffset(this.container);
            const { x, y } = this.coordinatesOffset(this.pressLocation.x, this.pressLocation.y);
            const slot = this.slotByPosition(x, y);
            this.dragging.offset = this.draggingOffset(slot, task);
            this.dragging.slot = slot;
            this.dragging.startResources = this.resourcesByIndex(slot.id.resourceIndex);
            this.dragging.resources = this.resourceValues(task, this.dragging.startResources);
        }
    }
    draggingOffset(slot, task) {
        return {
            start: slot.start.getTime() - task.startTime.getTime(),
            end: task.endTime.getTime() - slot.start.getTime()
        };
    }
    canDragTo(_task, _slot) {
        return true;
    }
    drag(args) {
        const { x, y } = this.coordinatesOffset(args.pageX, args.pageY);
        const slot = this.slotByPosition(x, y);
        if (slot && (slot !== this.dragging.slot || !this.dragHints.length)) {
            const dragging = this.dragging;
            const { slot: currentSlot, task } = dragging;
            const { ranges, start, end, isAllDay } = this.dragRanges(slot);
            const resources = this.resourcesByIndex(slot.id.resourceIndex);
            const resourceValues = currentSlot.id.resourceIndex !== slot.id.resourceIndex ?
                this.resourceValues(task, resources) : dragging.resources;
            this.removeSlotClass();
            dragging.start = start;
            dragging.end = end;
            dragging.slot = slot;
            dragging.resources = resourceValues;
            dragging.hintClass = null;
            if (!this.canDragTo(task, slot) ||
                this.emitEvent('drag', {
                    event: task.event,
                    dataItem: task.event.dataItem,
                    start: this.convertDate(start),
                    end: this.convertDate(end),
                    resources: resourceValues,
                    isAllDay,
                    setHintClass: this.setHintClass,
                    setSlotClass: this.setSlotClass
                })) {
                this.updateHintClass();
                return;
            }
            const color = this.dragResourceColor(task, resources);
            this.dragHints = [];
            for (let idx = 0; idx < ranges.length; idx++) {
                const slots = ranges[idx];
                const first = slots[0];
                const last = slots[slots.length - 1];
                const size = this.dragHintSize(first, last);
                let origin = first.rect.left;
                this.dragHints.push({
                    item: Object.assign({}, this.dragging.task, {
                        startTime: start,
                        endTime: end
                    }),
                    class: dragging.hintClass,
                    style: {
                        top: toPx(first.rect.top),
                        left: this.localization.rtl ? '' : toPx(origin),
                        right: !this.localization.rtl ? '' : toPx(origin),
                        width: size.width,
                        height: size.height,
                        backgroundColor: color,
                        borderColor: color
                    }
                });
            }
            this.updateHintContainer();
        }
    }
    dragResourceColor(task, slotResources) {
        if (this.groupedResources.length) {
            return getField(slotResources[0], this.groupedResources[0].colorField);
        }
        else if (this.resources && this.resources.length) {
            return task.resources[0].color;
        }
        return '';
    }
    resourceValues(task, currentResources) {
        const resources = this.groupedResources;
        const result = {};
        for (let idx = 0; idx < resources.length; idx++) {
            const resource = resources[idx];
            let value = getField(currentResources[idx], resource.valueField);
            if (resource.multiple) {
                const startValue = getField(this.dragging.startResources[idx], resource.valueField);
                if (startValue !== value) {
                    value = [value];
                }
                else {
                    value = getField(task.event.dataItem, resource.field);
                }
            }
            setField(result, resource.field, value);
        }
        return result;
    }
    resize(args) {
        const { x, y } = this.coordinatesOffset(args.pageX, args.pageY);
        const resizing = this.resizing;
        const { direction, task } = resizing;
        const slot = this.slotService.groupSlotByPosition(resizing.slot, x, y);
        if (!slot || slot === resizing.slot) {
            return;
        }
        this.removeSlotClass();
        const { start, end, ranges } = this.slotService.resizeRanges(slot, task, direction === 'w' || direction === 'n');
        resizing.hintClass = null;
        resizing.start = start;
        resizing.end = end;
        resizing.slot = slot;
        if (this.emitEvent('resize', {
            event: task.event,
            dataItem: task.event.dataItem,
            start: this.convertDate(start),
            end: this.convertDate(end),
            setHintClass: this.setHintClass,
            setSlotClass: this.setSlotClass
        })) {
            this.updateHintClass();
            return;
        }
        this.updateResizeHints(ranges, start, end);
        this.updateHintContainer();
    }
    updateResizeHints(ranges, start, end) {
        const resizing = this.resizing;
        const direction = resizing.direction;
        const horizontal = direction === 'w' || direction === 'e';
        this.resizeHints = [];
        for (let idx = 0; idx < ranges.length; idx++) {
            const range = ranges[idx];
            const firstSlot = range[0];
            const lastSlot = range[range.length - 1];
            this.resizeHints.push({
                first: idx === 0,
                last: idx === ranges.length - 1,
                rect: {
                    left: firstSlot.rect.left,
                    top: firstSlot.top,
                    height: horizontal ? firstSlot.height : Math.abs(lastSlot.rect.top - firstSlot.rect.top) + lastSlot.rect.height,
                    width: horizontal ? Math.abs(lastSlot.rect.left - firstSlot.rect.left) + lastSlot.rect.width : firstSlot.width
                },
                start: firstSlot.start,
                end: lastSlot.end,
                class: resizing.hintClass
            });
        }
    }
    coordinatesOffset(x, y) {
        const offset = this.containerOffset;
        const container = this.container;
        const position = x - offset.left + container.scrollLeft;
        return {
            x: !this.localization.rtl ? position : this.slotService.containerSize - position,
            y: y - offset.top + container.scrollTop
        };
    }
    initResizeContainer(target) {
        const container = closestInScope(target, node => hasClasses(node, 'k-scheduler-content'), this.element.nativeElement);
        if (container) {
            this.container = container;
            this.containerOffset = elementOffset(container);
        }
    }
    scrollContainer(callback, args) {
        const container = this.container;
        const viewPortY = args.pageY - this.containerOffset.top;
        const pointerYDistance = Math.abs(container.offsetHeight - viewPortY);
        const viewPortX = args.pageX - this.containerOffset.left;
        const pointerXDistance = Math.abs(container.offsetWidth - viewPortX);
        clearInterval(this.scrollInterval);
        let sroll = false;
        let leftChange = 0;
        let topChange = 0;
        if (pointerYDistance < MIN_DISTANCE && container.scrollTop + container.offsetHeight < container.scrollHeight) {
            sroll = true;
            topChange = SCROLL_CHANGE;
            this.container.scrollTop += MIN_DISTANCE - pointerYDistance;
        }
        else if (viewPortY < MIN_DISTANCE && container.scrollTop > 0) {
            sroll = true;
            topChange = -SCROLL_CHANGE;
            this.container.scrollTop -= MIN_DISTANCE - viewPortY;
        }
        if (pointerXDistance < MIN_DISTANCE && container.scrollLeft + container.offsetWidth < container.scrollWidth) {
            sroll = true;
            leftChange = SCROLL_CHANGE;
            this.container.scrollLeft += MIN_DISTANCE - pointerXDistance;
        }
        else if (viewPortX < MIN_DISTANCE && container.scrollLeft > 0) {
            sroll = true;
            leftChange = -SCROLL_CHANGE;
            this.container.scrollLeft -= MIN_DISTANCE - viewPortX;
        }
        if (sroll) {
            this.scrollInterval = setInterval(() => {
                this.container.scrollLeft += leftChange;
                this.container.scrollTop += topChange;
                callback.call(this, args);
            }, SCROLL_INTERVAL);
        }
    }
    emitEvent(name, args) {
        this.viewState.emitEvent(name, args);
        return args.prevented;
    }
    targetTask(target) {
        const eventTarget = closestInScope(target, node => node.hasAttribute('data-task-index'), this.element.nativeElement);
        if (eventTarget) {
            const index = parseInt(eventTarget.getAttribute('data-task-index'), 10);
            return {
                target: eventTarget,
                task: this.tasks.find(t => t.index === index)
            };
        }
    }
    updateHintContainer() {
        if (this.hintContainer) {
            this.hintContainer.detectChanges();
        }
    }
    convertDate(date) {
        return ZonedDate.fromUTCDate(date, this.timezone).toLocalDate();
    }
    onClick(e) {
        this.emitSlotEvent(e);
        this.emitTaskEvent(e);
    }
    emitSlotEvent(e) {
        const slotIndex = e.target.getAttribute('data-slot-index');
        if (slotIndex) {
            const name = e.type === 'dblclick' ? 'slotDblClick' : 'slotClick';
            const slot = this.slotByIndex(slotIndex, e);
            this.viewState.emitEvent(name, {
                type: e.type,
                slot: slot,
                start: toLocalDate(slot.start),
                end: toLocalDate(slot.end),
                isAllDay: slot.isDaySlot,
                originalEvent: e,
                resources: this.resources && this.resources.length ?
                    this.resourcesByIndex(slot.id.resourceIndex) : []
            });
        }
    }
    emitTaskEvent(e) {
        const targetTask = this.targetTask(e.target);
        if (targetTask) {
            const task = targetTask.task;
            if (e.type === 'click' && closestInScope(e.target, node => hasClasses(node, 'k-event-delete'), targetTask.target)) {
                e.preventDefault();
                this.viewState.emitEvent('remove', { event: task.event, dataItem: task.event.dataItem });
            }
            else {
                const name = e.type === 'dblclick' ? 'eventDblClick' : 'eventClick';
                this.viewState.emitEvent(name, { type: e.type, event: task.event, originalEvent: e });
            }
        }
    }
    syncTables() {
        if (this.timesTable) {
            this.renderer.setStyle(this.timesTable.nativeElement, 'height', `${this.contentTable.nativeElement.offsetHeight}px`);
        }
        if (this.header) {
            this.renderer.setStyle(this.header.nativeElement, !this.localization.rtl ? 'padding-right' : 'padding-left', `${hasScrollbar(this.content.nativeElement, 'vertical') ? scrollbarWidth() - BORDER_WIDTH : 0}px`);
            this.renderer.setStyle(this.header.nativeElement, this.localization.rtl ? 'padding-right' : 'padding-left', '0px');
        }
        if (this.times) {
            const times = this.times.nativeElement;
            this.timesHeader.nativeElement.style.width = `${times.offsetWidth}px`;
            const contentHeight = this.contentHeight === 'auto' ? this.content.nativeElement.offsetHeight : this.contentHeight;
            this.renderer.setStyle(times, 'height', `${contentHeight - (hasScrollbar(this.content.nativeElement, 'horizontal') ? scrollbarWidth() : 0)}px`);
        }
    }
    updateContentHeight() {
        const element = this.element.nativeElement;
        const parent = element.parentNode;
        const content = this.content.nativeElement;
        if (this.autoHeight || !parent.style.height) {
            this.contentHeight = 'auto';
            this.renderer.setStyle(content, 'height', '');
            if (this.times) {
                this.renderer.setStyle(this.times.nativeElement, 'height', '');
            }
            return;
        }
        let height = parent.clientHeight;
        for (let idx = 0; idx < parent.children.length; idx++) {
            const child = parent.children[idx];
            if (child !== element && !ignoreContentChild(child)) {
                height -= child.offsetHeight;
            }
        }
        height -= this.headerWrap ? this.headerWrap.nativeElement.offsetHeight : 0;
        this.renderer.setStyle(content, 'height', `${height}px`);
        this.contentHeight = height;
    }
    groupResources() {
        const resources = this.resources || [];
        const group = this.group || {};
        this.groupedResources = groupResources(group, resources);
        if (group.orientation !== 'vertical') {
            this.horizontalResources = this.groupedResources;
            this.verticalResources = [];
        }
        else {
            this.verticalResources = this.groupedResources;
            this.horizontalResources = [];
        }
        this.spans = this.resourceSpans();
    }
    get taskResources() {
        if (this.groupedResources.length) {
            return this.groupedResources;
        }
        else if (this.resources && this.resources.length) {
            return [this.resources[0]];
        }
        else {
            return [{}];
        }
    }
    resourceSpans() {
        const spans = [1];
        const resources = this.groupedResources;
        let span = 1;
        for (let idx = resources.length - 1; idx > 0; idx--) {
            span *= ((resources[idx].data || []).length || 1);
            spans.unshift(span);
        }
        return spans;
    }
    isInRange(date) {
        const dateRange = this.dateRange(date);
        return (!this.min || this.min < dateRange.end) && (!this.max || dateRange.start <= this.max);
    }
    createPDFElement() {
        const contentHeight = this.contentHeight;
        if (contentHeight !== 'auto') {
            this.autoHeight = true;
            this.updateView();
        }
        const element = this.element.nativeElement.cloneNode(true);
        element.style.width = `${this.pdfWidth()}px`;
        if (contentHeight !== 'auto') {
            this.autoHeight = false;
            this.updateView();
        }
        this.pdfService.elementReady.emit({
            element: element
        });
    }
    pdfWidth() {
        return this.element.nativeElement.offsetWidth;
    }
}
BaseView.propDecorators = {
    'ÐµventTemplate': [{ type: Input },],
    'groupHeaderTemplate': [{ type: Input },],
    'selectedDateFormat': [{ type: Input },],
    'selectedShortDateFormat': [{ type: Input },],
    'eventHeight': [{ type: Input },],
    'content': [{ type: ViewChild, args: ['content',] },],
    'header': [{ type: ViewChild, args: ['header',] },],
    'contentTable': [{ type: ViewChild, args: ['contentTable',] },],
    'times': [{ type: ViewChild, args: ['times',] },],
    'timesHeader': [{ type: ViewChild, args: ['timesHeader',] },],
    'timesTable': [{ type: ViewChild, args: ['timesTable',] },],
    'headerWrap': [{ type: ViewChild, args: ['headerWrap',] },],
    'hintContainer': [{ type: ViewChild, args: ['hintContainer',] },],
};
