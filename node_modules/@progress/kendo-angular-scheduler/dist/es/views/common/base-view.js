import { ViewChild, Input } from '@angular/core';
import { toLocalDate, ZonedDate } from '@progress/kendo-date-math';
import { Subscription } from 'rxjs/Subscription';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { switchMap } from 'rxjs/operators/switchMap';
import { take } from 'rxjs/operators/take';
import { combineLatest } from 'rxjs/operators/combineLatest';
import { fromEvent } from 'rxjs/observable/fromEvent';
import { merge } from 'rxjs/observable/merge';
import { map } from 'rxjs/operators/map';
import { filter } from 'rxjs/operators/filter';
import { tap } from 'rxjs/operators/tap';
import { closestInScope, hasClasses, preventLockedScroll, scrollbarWidth, wheelDeltaY, hasScrollbar } from '../../common/dom-queries';
import { groupResources, getField, setField } from '../../common/util';
import { anyChanged } from '../../common/changes';
import { assignTasksResources, toPx, elementOffset, pointDistance, ignoreContentChild } from '../utils';
import { BORDER_WIDTH } from '../constants';
import Draggable from '@telerik/kendo-draggable';
var SCROLL_CHANGE = 15;
var MIN_DISTANCE = 60;
var SCROLL_INTERVAL = 50;
var MIN_MOVE_DISTANCE = 10;
/** @hidden */
var BaseView = /** @class */ (function () {
    function BaseView(viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization) {
        this.viewContext = viewContext;
        this.viewState = viewState;
        this.intl = intl;
        this.slotService = slotService;
        this.zone = zone;
        this.renderer = renderer;
        this.element = element;
        this.pdfService = pdfService;
        this.localization = localization;
        this.items = new BehaviorSubject(null);
        this.horizontalResources = [];
        this.verticalResources = [];
        this.dragHints = [];
        this.resizeHints = [];
        this.getField = getField;
        this.changes = new BehaviorSubject(null);
        this.subs = new Subscription();
        this.groupedResources = [];
        this.spans = [];
        this.domEvents = [];
        this.resourcesCache = {};
        this.autoHeight = false;
        this.rtl = false;
        this.setSlotClass = this.setSlotClass.bind(this);
        this.setHintClass = this.setHintClass.bind(this);
    }
    Object.defineProperty(BaseView.prototype, "eventTemplateRef", {
        get: function () {
            return this.еventTemplate || (this.schedulerEventTemplate || {}).templateRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseView.prototype, "groupHeaderTemplateRef", {
        get: function () {
            return this.groupHeaderTemplate || (this.schedulerGroupHeaderTemplate || {}).templateRef;
        },
        enumerable: true,
        configurable: true
    });
    BaseView.prototype.ngOnInit = function () {
        var _this = this;
        var updateView = this.updateView.bind(this);
        this.resourcesByIndex = this.resourcesByIndex.bind(this);
        this.subs.add(this.viewContext.selectedDate.subscribe(this.onSelectDate.bind(this)));
        this.subs.add(this.viewContext.action.subscribe(this.onAction.bind(this)));
        this.subs.add(this.viewContext.resize.subscribe(updateView));
        this.subs.add(this.viewContext.optionsChange.subscribe(this.optionsChange.bind(this)));
        this.subs.add(this.changes.subscribe(function () {
            _this.toggleElement(false);
        }));
        this.subs.add(this.viewContext.items.pipe(combineLatest(this.viewState.dateRange, this.createTasks.bind(this)))
            .subscribe(function (tasks) {
            _this.tasks = tasks;
            _this.assignResources();
            _this.onTasksChange();
        }));
        this.subs.add(this.items.pipe(combineLatest(this.changes, this.localization.changes), switchMap(this.onStable.bind(this), function (args) { return args; }))
            .subscribe(updateView));
        this.subs.add(this.pdfService.createElement.subscribe(this.createPDFElement.bind(this)));
    };
    BaseView.prototype.ngOnChanges = function (changes) {
        if (anyChanged(['selectedDateFormat', 'selectedShortDateFormat'], changes)) {
            this.viewState.notifyDateRange(this.dateRange(this.selectedDate));
        }
        if (changes.eventHeight) {
            this.changes.next(null);
        }
    };
    BaseView.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.bindEvents();
        this.subs.add(this.localization.changes.subscribe(function (_a) {
            var rtl = _a.rtl;
            var prev = _this.rtl;
            _this.rtl = rtl;
            if (prev !== rtl) {
                _this.reflow();
            }
        }));
    };
    BaseView.prototype.ngOnDestroy = function () {
        this.subs.unsubscribe();
        this.domEvents.forEach(function (unbindHandler) { return unbindHandler(); });
        this.domEvents = [];
        if (this.draggable) {
            this.draggable.destroy();
            this.draggable = null;
        }
    };
    BaseView.prototype.itemIndex = function (index, _) {
        return index;
    };
    BaseView.prototype.resourcesByIndex = function (index) {
        if (!this.resourcesCache[index]) {
            var resources = this.taskResources;
            var result = [];
            var currentIndex = index;
            for (var idx = 0; idx < resources.length; idx++) {
                var data = resources[idx].data || [];
                var dataIdx = Math.floor(currentIndex / this.spans[idx]);
                result.push(data[dataIdx]);
                currentIndex -= dataIdx * this.spans[idx];
            }
            this.resourcesCache[index] = result;
        }
        return this.resourcesCache[index];
    };
    BaseView.prototype.optionsChange = function (options) {
        this.schedulerEventTemplate = options.eventTemplate;
        this.schedulerGroupHeaderTemplate = options.groupHeaderTemplate;
        this.min = options.min;
        this.max = options.max;
        this.editable = options.editable;
        this.timezone = options.timezone;
        if (!options.changes || anyChanged(['group', 'resources'], options.changes, false)) {
            this.group = options.group;
            this.resources = options.resources;
            this.groupResources();
            this.resourcesCache = {};
            if (this.tasks && this.tasks.length) {
                this.assignResources();
                this.onTasksChange();
            }
            this.changes.next(null);
        }
    };
    BaseView.prototype.toggleElement = function (visible) {
        if (this.element) {
            this.renderer.setStyle(this.element.nativeElement, 'display', visible ? 'block' : 'none');
        }
    };
    BaseView.prototype.onStable = function () {
        return this.zone.onStable.asObservable().pipe(take(1));
    };
    BaseView.prototype.updateView = function () {
        this.slotService.invalidate();
        this.toggleElement(true);
        this.reflow();
        this.viewState.notifyLayoutEnd();
    };
    BaseView.prototype.assignResources = function () {
        assignTasksResources(this.tasks, this.taskResources, this.groupedResources.length > 0, this.spans);
    };
    BaseView.prototype.bindEvents = function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            if (_this.times) {
                _this.subs.add(merge(fromEvent(_this.times.nativeElement, 'mousewheel'), fromEvent(_this.times.nativeElement, 'DOMMouseScroll')).pipe(filter(function (event) { return !event.ctrlKey; }), tap(preventLockedScroll(_this.content.nativeElement)), map(wheelDeltaY))
                    .subscribe(function (x) { return _this.content.nativeElement.scrollTop -= x; }));
            }
            var clickHandler = _this.onClick = _this.onClick.bind(_this);
            _this.domEvents.push(_this.renderer.listen(_this.content.nativeElement, 'scroll', function () {
                if (_this.headerWrap) {
                    _this.headerWrap.nativeElement.scrollLeft = _this.content.nativeElement.scrollLeft;
                }
                if (_this.times) {
                    _this.times.nativeElement.scrollTop = _this.content.nativeElement.scrollTop;
                }
            }), _this.renderer.listen(_this.content.nativeElement, 'click', clickHandler), _this.renderer.listen(_this.content.nativeElement, 'dblclick', clickHandler), _this.renderer.listen(_this.content.nativeElement, 'contextmenu', clickHandler));
            _this.draggable = new Draggable({
                press: _this.onPress.bind(_this),
                drag: _this.onDrag.bind(_this),
                release: _this.onRelease.bind(_this)
            });
            _this.draggable.bindTo(_this.element.nativeElement);
        });
    };
    BaseView.prototype.onPress = function (args) {
        var resizable = this.editable && this.editable.resize !== false;
        var draggable = this.editable && this.editable.drag !== false;
        var target = args.originalEvent.target;
        if (hasClasses(target, 'k-resize-handle')) {
            if (!resizable) {
                return;
            }
            args.originalEvent.preventDefault();
            var resizing = this.targetTask(target);
            if (this.emitEvent('resizeStart', { event: resizing.task.event, dataItem: resizing.task.event.dataItem })) {
                return;
            }
            this.resizing = resizing;
            resizing.start = resizing.task.start.toUTCDate();
            resizing.end = resizing.task.end.toUTCDate();
            if (hasClasses(target, 'k-resize-n')) {
                resizing.direction = 'n';
            }
            else if (hasClasses(target, 'k-resize-s')) {
                resizing.direction = 's';
            }
            else if (hasClasses(target, 'k-resize-w')) {
                resizing.direction = 'w';
            }
            else {
                resizing.direction = 'e';
            }
            this.initResizeContainer(target);
            var _a = this.coordinatesOffset(args.pageX, args.pageY), x = _a.x, y = _a.y;
            resizing.slot = this.slotByPosition(x, y);
        }
        else if (draggable) {
            args.originalEvent.preventDefault();
            var task = this.targetTask(target);
            if (task) {
                this.pressLocation = { x: args.pageX, y: args.pageY };
                this.pressTarget = task;
            }
        }
    };
    BaseView.prototype.onDrag = function (args) {
        if (this.resizing) {
            this.resize(args);
            this.scrollContainer(this.resize, args);
        }
        else {
            this.initDrag(args);
            if (this.dragging) {
                this.drag(args);
                this.scrollContainer(this.drag, args);
            }
        }
    };
    BaseView.prototype.onRelease = function () {
        clearInterval(this.scrollInterval);
        var _a = this, resizing = _a.resizing, dragging = _a.dragging;
        if (resizing) {
            this.emitEvent('resizeEnd', {
                event: resizing.task.event,
                dataItem: resizing.task.event.dataItem,
                start: this.convertDate(resizing.start),
                end: this.convertDate(resizing.end)
            });
            this.resizeHints = [];
        }
        if (dragging) {
            this.emitEvent('dragEnd', {
                event: dragging.task.event,
                dataItem: dragging.task.event.dataItem,
                start: this.convertDate(dragging.start),
                end: this.convertDate(dragging.end),
                resources: dragging.resources,
                isAllDay: Boolean(dragging.slot.isDaySlot)
            });
            this.pressLocation = null;
            this.pressTarget = null;
            this.dragHints = [];
        }
        if (resizing || dragging) {
            this.removeSlotClass();
            this.updateHintContainer();
            this.resizing = null;
            this.dragging = null;
        }
        this.container = null;
    };
    BaseView.prototype.setHintClass = function (className) {
        (this.dragging || this.resizing).hintClass = className;
    };
    BaseView.prototype.updateHintClass = function () {
        var current = this.dragging || this.resizing;
        var update = false;
        this.hints.forEach(function (hint) {
            if (hint.class !== current.hintClass) {
                hint.class = current.hintClass;
                update = true;
            }
        });
        if (update) {
            this.updateHintContainer();
        }
    };
    BaseView.prototype.removeHintClass = function () {
        (this.dragging || this.resizing).hintClass = null;
    };
    BaseView.prototype.setSlotClass = function (className) {
        var current = this.dragging || this.resizing;
        current.slotClass = className;
        this.renderer.addClass(current.slot.nativeElement, current.slotClass);
    };
    BaseView.prototype.removeSlotClass = function () {
        var current = this.dragging || this.resizing;
        if (current.slotClass) {
            this.renderer.removeClass(current.slot.nativeElement, current.slotClass);
            current.slotClass = null;
        }
    };
    Object.defineProperty(BaseView.prototype, "hints", {
        get: function () {
            return this.dragging ? this.dragHints : this.resizeHints;
        },
        enumerable: true,
        configurable: true
    });
    BaseView.prototype.initDrag = function (args) {
        if (!this.dragging && this.pressLocation && pointDistance(this.pressLocation.x, this.pressLocation.y, args.pageX, args.pageY) >= MIN_MOVE_DISTANCE) {
            var dragging = this.pressTarget;
            var task = dragging.task;
            if (this.emitEvent('dragStart', { event: task.event, dataItem: task.event.dataItem })) {
                this.pressLocation = null;
                this.pressTarget = null;
                return;
            }
            this.dragging = dragging;
            this.container = this.content.nativeElement;
            this.containerOffset = elementOffset(this.container);
            var _a = this.coordinatesOffset(this.pressLocation.x, this.pressLocation.y), x = _a.x, y = _a.y;
            var slot = this.slotByPosition(x, y);
            this.dragging.offset = this.draggingOffset(slot, task);
            this.dragging.slot = slot;
            this.dragging.startResources = this.resourcesByIndex(slot.id.resourceIndex);
            this.dragging.resources = this.resourceValues(task, this.dragging.startResources);
        }
    };
    BaseView.prototype.draggingOffset = function (slot, task) {
        return {
            start: slot.start.getTime() - task.startTime.getTime(),
            end: task.endTime.getTime() - slot.start.getTime()
        };
    };
    BaseView.prototype.canDragTo = function (_task, _slot) {
        return true;
    };
    BaseView.prototype.drag = function (args) {
        var _a = this.coordinatesOffset(args.pageX, args.pageY), x = _a.x, y = _a.y;
        var slot = this.slotByPosition(x, y);
        if (slot && (slot !== this.dragging.slot || !this.dragHints.length)) {
            var dragging = this.dragging;
            var currentSlot = dragging.slot, task = dragging.task;
            var _b = this.dragRanges(slot), ranges = _b.ranges, start = _b.start, end = _b.end, isAllDay = _b.isAllDay;
            var resources = this.resourcesByIndex(slot.id.resourceIndex);
            var resourceValues = currentSlot.id.resourceIndex !== slot.id.resourceIndex ?
                this.resourceValues(task, resources) : dragging.resources;
            this.removeSlotClass();
            dragging.start = start;
            dragging.end = end;
            dragging.slot = slot;
            dragging.resources = resourceValues;
            dragging.hintClass = null;
            if (!this.canDragTo(task, slot) ||
                this.emitEvent('drag', {
                    event: task.event,
                    dataItem: task.event.dataItem,
                    start: this.convertDate(start),
                    end: this.convertDate(end),
                    resources: resourceValues,
                    isAllDay: isAllDay,
                    setHintClass: this.setHintClass,
                    setSlotClass: this.setSlotClass
                })) {
                this.updateHintClass();
                return;
            }
            var color = this.dragResourceColor(task, resources);
            this.dragHints = [];
            for (var idx = 0; idx < ranges.length; idx++) {
                var slots = ranges[idx];
                var first = slots[0];
                var last = slots[slots.length - 1];
                var size = this.dragHintSize(first, last);
                var origin = first.rect.left;
                this.dragHints.push({
                    item: Object.assign({}, this.dragging.task, {
                        startTime: start,
                        endTime: end
                    }),
                    class: dragging.hintClass,
                    style: {
                        top: toPx(first.rect.top),
                        left: this.localization.rtl ? '' : toPx(origin),
                        right: !this.localization.rtl ? '' : toPx(origin),
                        width: size.width,
                        height: size.height,
                        backgroundColor: color,
                        borderColor: color
                    }
                });
            }
            this.updateHintContainer();
        }
    };
    BaseView.prototype.dragResourceColor = function (task, slotResources) {
        if (this.groupedResources.length) {
            return getField(slotResources[0], this.groupedResources[0].colorField);
        }
        else if (this.resources && this.resources.length) {
            return task.resources[0].color;
        }
        return '';
    };
    BaseView.prototype.resourceValues = function (task, currentResources) {
        var resources = this.groupedResources;
        var result = {};
        for (var idx = 0; idx < resources.length; idx++) {
            var resource = resources[idx];
            var value = getField(currentResources[idx], resource.valueField);
            if (resource.multiple) {
                var startValue = getField(this.dragging.startResources[idx], resource.valueField);
                if (startValue !== value) {
                    value = [value];
                }
                else {
                    value = getField(task.event.dataItem, resource.field);
                }
            }
            setField(result, resource.field, value);
        }
        return result;
    };
    BaseView.prototype.resize = function (args) {
        var _a = this.coordinatesOffset(args.pageX, args.pageY), x = _a.x, y = _a.y;
        var resizing = this.resizing;
        var direction = resizing.direction, task = resizing.task;
        var slot = this.slotService.groupSlotByPosition(resizing.slot, x, y);
        if (!slot || slot === resizing.slot) {
            return;
        }
        this.removeSlotClass();
        var _b = this.slotService.resizeRanges(slot, task, direction === 'w' || direction === 'n'), start = _b.start, end = _b.end, ranges = _b.ranges;
        resizing.hintClass = null;
        resizing.start = start;
        resizing.end = end;
        resizing.slot = slot;
        if (this.emitEvent('resize', {
            event: task.event,
            dataItem: task.event.dataItem,
            start: this.convertDate(start),
            end: this.convertDate(end),
            setHintClass: this.setHintClass,
            setSlotClass: this.setSlotClass
        })) {
            this.updateHintClass();
            return;
        }
        this.updateResizeHints(ranges, start, end);
        this.updateHintContainer();
    };
    BaseView.prototype.updateResizeHints = function (ranges, start, end) {
        var resizing = this.resizing;
        var direction = resizing.direction;
        var horizontal = direction === 'w' || direction === 'e';
        this.resizeHints = [];
        for (var idx = 0; idx < ranges.length; idx++) {
            var range = ranges[idx];
            var firstSlot = range[0];
            var lastSlot = range[range.length - 1];
            this.resizeHints.push({
                first: idx === 0,
                last: idx === ranges.length - 1,
                rect: {
                    left: firstSlot.rect.left,
                    top: firstSlot.top,
                    height: horizontal ? firstSlot.height : Math.abs(lastSlot.rect.top - firstSlot.rect.top) + lastSlot.rect.height,
                    width: horizontal ? Math.abs(lastSlot.rect.left - firstSlot.rect.left) + lastSlot.rect.width : firstSlot.width
                },
                start: firstSlot.start,
                end: lastSlot.end,
                class: resizing.hintClass
            });
        }
    };
    BaseView.prototype.coordinatesOffset = function (x, y) {
        var offset = this.containerOffset;
        var container = this.container;
        var position = x - offset.left + container.scrollLeft;
        return {
            x: !this.localization.rtl ? position : this.slotService.containerSize - position,
            y: y - offset.top + container.scrollTop
        };
    };
    BaseView.prototype.initResizeContainer = function (target) {
        var container = closestInScope(target, function (node) { return hasClasses(node, 'k-scheduler-content'); }, this.element.nativeElement);
        if (container) {
            this.container = container;
            this.containerOffset = elementOffset(container);
        }
    };
    BaseView.prototype.scrollContainer = function (callback, args) {
        var _this = this;
        var container = this.container;
        var viewPortY = args.pageY - this.containerOffset.top;
        var pointerYDistance = Math.abs(container.offsetHeight - viewPortY);
        var viewPortX = args.pageX - this.containerOffset.left;
        var pointerXDistance = Math.abs(container.offsetWidth - viewPortX);
        clearInterval(this.scrollInterval);
        var sroll = false;
        var leftChange = 0;
        var topChange = 0;
        if (pointerYDistance < MIN_DISTANCE && container.scrollTop + container.offsetHeight < container.scrollHeight) {
            sroll = true;
            topChange = SCROLL_CHANGE;
            this.container.scrollTop += MIN_DISTANCE - pointerYDistance;
        }
        else if (viewPortY < MIN_DISTANCE && container.scrollTop > 0) {
            sroll = true;
            topChange = -SCROLL_CHANGE;
            this.container.scrollTop -= MIN_DISTANCE - viewPortY;
        }
        if (pointerXDistance < MIN_DISTANCE && container.scrollLeft + container.offsetWidth < container.scrollWidth) {
            sroll = true;
            leftChange = SCROLL_CHANGE;
            this.container.scrollLeft += MIN_DISTANCE - pointerXDistance;
        }
        else if (viewPortX < MIN_DISTANCE && container.scrollLeft > 0) {
            sroll = true;
            leftChange = -SCROLL_CHANGE;
            this.container.scrollLeft -= MIN_DISTANCE - viewPortX;
        }
        if (sroll) {
            this.scrollInterval = setInterval(function () {
                _this.container.scrollLeft += leftChange;
                _this.container.scrollTop += topChange;
                callback.call(_this, args);
            }, SCROLL_INTERVAL);
        }
    };
    BaseView.prototype.emitEvent = function (name, args) {
        this.viewState.emitEvent(name, args);
        return args.prevented;
    };
    BaseView.prototype.targetTask = function (target) {
        var eventTarget = closestInScope(target, function (node) { return node.hasAttribute('data-task-index'); }, this.element.nativeElement);
        if (eventTarget) {
            var index_1 = parseInt(eventTarget.getAttribute('data-task-index'), 10);
            return {
                target: eventTarget,
                task: this.tasks.find(function (t) { return t.index === index_1; })
            };
        }
    };
    BaseView.prototype.updateHintContainer = function () {
        if (this.hintContainer) {
            this.hintContainer.detectChanges();
        }
    };
    BaseView.prototype.convertDate = function (date) {
        return ZonedDate.fromUTCDate(date, this.timezone).toLocalDate();
    };
    BaseView.prototype.onClick = function (e) {
        this.emitSlotEvent(e);
        this.emitTaskEvent(e);
    };
    BaseView.prototype.emitSlotEvent = function (e) {
        var slotIndex = e.target.getAttribute('data-slot-index');
        if (slotIndex) {
            var name_1 = e.type === 'dblclick' ? 'slotDblClick' : 'slotClick';
            var slot = this.slotByIndex(slotIndex, e);
            this.viewState.emitEvent(name_1, {
                type: e.type,
                slot: slot,
                start: toLocalDate(slot.start),
                end: toLocalDate(slot.end),
                isAllDay: slot.isDaySlot,
                originalEvent: e,
                resources: this.resources && this.resources.length ?
                    this.resourcesByIndex(slot.id.resourceIndex) : []
            });
        }
    };
    BaseView.prototype.emitTaskEvent = function (e) {
        var targetTask = this.targetTask(e.target);
        if (targetTask) {
            var task = targetTask.task;
            if (e.type === 'click' && closestInScope(e.target, function (node) { return hasClasses(node, 'k-event-delete'); }, targetTask.target)) {
                e.preventDefault();
                this.viewState.emitEvent('remove', { event: task.event, dataItem: task.event.dataItem });
            }
            else {
                var name_2 = e.type === 'dblclick' ? 'eventDblClick' : 'eventClick';
                this.viewState.emitEvent(name_2, { type: e.type, event: task.event, originalEvent: e });
            }
        }
    };
    BaseView.prototype.syncTables = function () {
        if (this.timesTable) {
            this.renderer.setStyle(this.timesTable.nativeElement, 'height', this.contentTable.nativeElement.offsetHeight + "px");
        }
        if (this.header) {
            this.renderer.setStyle(this.header.nativeElement, !this.localization.rtl ? 'padding-right' : 'padding-left', (hasScrollbar(this.content.nativeElement, 'vertical') ? scrollbarWidth() - BORDER_WIDTH : 0) + "px");
            this.renderer.setStyle(this.header.nativeElement, this.localization.rtl ? 'padding-right' : 'padding-left', '0px');
        }
        if (this.times) {
            var times = this.times.nativeElement;
            this.timesHeader.nativeElement.style.width = times.offsetWidth + "px";
            var contentHeight = this.contentHeight === 'auto' ? this.content.nativeElement.offsetHeight : this.contentHeight;
            this.renderer.setStyle(times, 'height', contentHeight - (hasScrollbar(this.content.nativeElement, 'horizontal') ? scrollbarWidth() : 0) + "px");
        }
    };
    BaseView.prototype.updateContentHeight = function () {
        var element = this.element.nativeElement;
        var parent = element.parentNode;
        var content = this.content.nativeElement;
        if (this.autoHeight || !parent.style.height) {
            this.contentHeight = 'auto';
            this.renderer.setStyle(content, 'height', '');
            if (this.times) {
                this.renderer.setStyle(this.times.nativeElement, 'height', '');
            }
            return;
        }
        var height = parent.clientHeight;
        for (var idx = 0; idx < parent.children.length; idx++) {
            var child = parent.children[idx];
            if (child !== element && !ignoreContentChild(child)) {
                height -= child.offsetHeight;
            }
        }
        height -= this.headerWrap ? this.headerWrap.nativeElement.offsetHeight : 0;
        this.renderer.setStyle(content, 'height', height + "px");
        this.contentHeight = height;
    };
    BaseView.prototype.groupResources = function () {
        var resources = this.resources || [];
        var group = this.group || {};
        this.groupedResources = groupResources(group, resources);
        if (group.orientation !== 'vertical') {
            this.horizontalResources = this.groupedResources;
            this.verticalResources = [];
        }
        else {
            this.verticalResources = this.groupedResources;
            this.horizontalResources = [];
        }
        this.spans = this.resourceSpans();
    };
    Object.defineProperty(BaseView.prototype, "taskResources", {
        get: function () {
            if (this.groupedResources.length) {
                return this.groupedResources;
            }
            else if (this.resources && this.resources.length) {
                return [this.resources[0]];
            }
            else {
                return [{}];
            }
        },
        enumerable: true,
        configurable: true
    });
    BaseView.prototype.resourceSpans = function () {
        var spans = [1];
        var resources = this.groupedResources;
        var span = 1;
        for (var idx = resources.length - 1; idx > 0; idx--) {
            span *= ((resources[idx].data || []).length || 1);
            spans.unshift(span);
        }
        return spans;
    };
    BaseView.prototype.isInRange = function (date) {
        var dateRange = this.dateRange(date);
        return (!this.min || this.min < dateRange.end) && (!this.max || dateRange.start <= this.max);
    };
    BaseView.prototype.createPDFElement = function () {
        var contentHeight = this.contentHeight;
        if (contentHeight !== 'auto') {
            this.autoHeight = true;
            this.updateView();
        }
        var element = this.element.nativeElement.cloneNode(true);
        element.style.width = this.pdfWidth() + "px";
        if (contentHeight !== 'auto') {
            this.autoHeight = false;
            this.updateView();
        }
        this.pdfService.elementReady.emit({
            element: element
        });
    };
    BaseView.prototype.pdfWidth = function () {
        return this.element.nativeElement.offsetWidth;
    };
    BaseView.propDecorators = {
        'еventTemplate': [{ type: Input },],
        'groupHeaderTemplate': [{ type: Input },],
        'selectedDateFormat': [{ type: Input },],
        'selectedShortDateFormat': [{ type: Input },],
        'eventHeight': [{ type: Input },],
        'content': [{ type: ViewChild, args: ['content',] },],
        'header': [{ type: ViewChild, args: ['header',] },],
        'contentTable': [{ type: ViewChild, args: ['contentTable',] },],
        'times': [{ type: ViewChild, args: ['times',] },],
        'timesHeader': [{ type: ViewChild, args: ['timesHeader',] },],
        'timesTable': [{ type: ViewChild, args: ['timesTable',] },],
        'headerWrap': [{ type: ViewChild, args: ['headerWrap',] },],
        'hintContainer': [{ type: ViewChild, args: ['hintContainer',] },],
    };
    return BaseView;
}());
export { BaseView };
