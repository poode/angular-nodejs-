import { isPresent, getField } from '../common/util';
import { hasClasses } from '../common/dom-queries';
/** @hidden */
export var intersects = function (startTime, endTime, periodStart, periodEnd) {
    return (startTime < periodStart && endTime > periodEnd) ||
        (periodStart <= startTime && startTime < periodEnd) ||
        (periodStart < endTime && endTime <= periodEnd && startTime < endTime);
};
/** @hidden */
export var dateInRange = function (date, start, end) { return start.getTime() <= date.getTime() && date.getTime() <= end.getTime(); };
/** @hidden */
export var roundAllDayEnd = function (_a) {
    var start = _a.start, end = _a.end;
    var startDate = start.stripTime();
    var endDate = end.stripTime();
    return endDate.getTime() !== end.getTime() || startDate.getTime() === endDate.getTime() ? endDate.addDays(1) : endDate;
};
/** @hidden */
export function toInvariantTime(date) {
    var staticDate = new Date(1980, 1, 1, 0, 0, 0);
    if (date) {
        staticDate.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
    }
    return staticDate;
}
/**
 * @hidden
 * TODO Move to date-math
 */
export var addUTCDays = function (date, offset) {
    var newDate = new Date(date.getTime());
    newDate.setUTCDate(newDate.getUTCDate() + offset);
    return newDate;
};
// TODO: name? move to date-math
/** @hidden */
export function toUTCTime(localDate, localTime) {
    return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), localTime.getHours(), localTime.getMinutes(), localTime.getSeconds(), localTime.getMilliseconds()));
}
//  TODO: move to date-math
/** @hidden */
export function toUTCDate(localDate) {
    return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate()));
}
// TODO: move to date-math
/** @hidden */
export function getUTCDate(utcDate) {
    return new Date(Date.UTC(utcDate.getUTCFullYear(), utcDate.getUTCMonth(), utcDate.getUTCDate()));
}
// TODO: move to date-math
/** @hidden */
export function toUTCDateTime(localDate) {
    return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), localDate.getHours(), localDate.getMinutes(), localDate.getSeconds(), localDate.getMilliseconds()));
}
function getDataIdx(value, resource) {
    var data = resource.data;
    for (var dataIdx = 0; dataIdx < data.length; dataIdx++) {
        if (getField(data[dataIdx], resource.valueField) === value) {
            return dataIdx;
        }
    }
    return 0;
}
function cloneArray(arr) {
    var clone = [];
    for (var idx = 0; idx < arr.length; idx++) {
        clone.push(Object.assign({}, arr[idx]));
    }
    return clone;
}
/** @hidden */
export function eventResources(event, taskResources, hasGroups, spans) {
    var resources = [];
    var resourceItems = [];
    for (var resourceIdx = 0; resourceIdx < taskResources.length; resourceIdx++) {
        var resource = taskResources[resourceIdx];
        if (!resource.data) {
            resources = [{ leafIdx: 0, resources: resourceItems }];
            continue;
        }
        var values = getField(event, resource.field);
        if (!Array.isArray(values)) {
            values = [values];
        }
        var expandedResources = [];
        for (var valueIdx = 0; valueIdx < values.length; valueIdx++) {
            var dataIdx = getDataIdx(values[valueIdx], resource);
            resourceItems.push(resource.data[dataIdx]);
            // has groups - need all copies of the multiple resource
            // no groups - just the first
            if (resourceIdx === 0 && (hasGroups || valueIdx === 0)) {
                resources.push({
                    leafIdx: hasGroups ? dataIdx * spans[resourceIdx] : 0,
                    color: getField(resource.data[dataIdx], resource.colorField),
                    resources: resourceItems
                });
            }
            else if (hasGroups) {
                var currentResources = resources;
                if (values.length > 1) {
                    currentResources = cloneArray(resources);
                    expandedResources.push.apply(expandedResources, currentResources);
                }
                for (var currentIdx = 0; currentIdx < currentResources.length; currentIdx++) {
                    currentResources[currentIdx].leafIdx += dataIdx * spans[resourceIdx];
                }
            }
        }
        if (expandedResources.length) {
            resources = expandedResources;
        }
    }
    return resources;
}
/** @hidden */
export function assignTasksResources(tasks, taskResources, hasGroups, spans) {
    for (var idx = 0; idx < tasks.length; idx++) {
        var task = tasks[idx];
        task.resources = eventResources(task.event, taskResources, hasGroups, spans);
    }
}
/** @hidden */
export function findRowIndex(events, data) {
    if (data.rowIndex !== undefined) {
        return data.rowIndex;
    }
    for (var idx = 0; idx < events.length; idx++) {
        if (!events[idx]) {
            return idx;
        }
    }
    return events.length;
}
/** @hidden */
export function isRecurrence(task) {
    return Boolean(task.event && task.event.recurrenceRule);
}
/** @hidden */
export function isRecurrenceException(task) {
    return task.event && isPresent(task.event.recurrenceId) && !task.event.recurrenceRule;
}
/** @hidden */
export var rectContains = function (rect, left, top) {
    return rect.left <= left && left <= rect.left + rect.width && rect.top <= top && top <= rect.top + rect.height;
};
/** @hidden */
export var rectContainsX = function (rect, left) {
    return rect.left <= left && left <= rect.left + rect.width;
};
/** @hidden */
export var toPx = function (value) { return value + "px"; };
/** @hidden */
export var elementOffset = function (element) {
    var box = element.getBoundingClientRect();
    var documentElement = document.documentElement;
    return {
        top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),
        left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0),
        width: box.width,
        height: box.height
    };
};
/** @hidden */
export var pointDistance = function (x1, y1, x2, y2) { return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)); };
/** @hidden */
export var ignoreContentChild = function (child) { return child.nodeName === 'KENDO-RESIZE-SENSOR' || hasClasses(child, 'k-loading-mask'); };
/** @hidden */
export var setCoordinates = function (element, coordinates) {
    for (var field in coordinates) {
        if (coordinates.hasOwnProperty(field)) {
            element.style[field] = toPx(coordinates[field]);
        }
    }
};
