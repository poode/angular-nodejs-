import * as tslib_1 from "tslib";
import { orderBy } from '@progress/kendo-data-query';
import { intersects, findRowIndex } from '../utils';
import { ItemMap } from '../view-items/item-map';
import { BaseSlotService } from '../view-items/base-slot.service';
import { BORDER_WIDTH } from '../constants';
import { rectContains, rectContainsX, dateInRange } from '../utils';
var EVENTS_OFFSET = 10;
function initHorizontalSlots(slots, items, rowHeight, eventHeight) {
    var padding = slots[0].padding;
    if (!items.length) {
        return {
            height: rowHeight - padding
        };
    }
    items.forEach(function (item) {
        item.rowIndex = undefined;
        item.rect = {
            height: eventHeight,
            width: 0
        };
    });
    var sorted = orderBy(items, [{ field: "item.startTime", dir: "asc" }, { field: "item.endTime", dir: "desc" }]);
    var slotItems = {};
    sorted.forEach(function (event) { return slots
        .filter(function (slot) { return intersects(event.item.startTime, event.item.endTime, slot.start, slot.end); })
        .forEach(function (slot) {
        var value = slotItems[slot.key] = slotItems[slot.key] || { events: [], slot: slot };
        event.rowIndex = findRowIndex(value.events, event);
        value.events[event.rowIndex] = event;
    }); });
    var top = slots[0].top;
    var maxOffset = 0;
    Object.keys(slotItems).forEach(function (key) {
        var events = slotItems[key].events;
        var slotOffset = 0;
        for (var idx = 0; idx < events.length; idx++) {
            var event_1 = events[idx];
            if (event_1) {
                event_1.rect.top = top + idx * (EVENTS_OFFSET + event_1.rect.height);
                slotOffset = (event_1.rect.top - top) + event_1.rect.height;
            }
        }
        maxOffset = Math.max(slotOffset, maxOffset);
    });
    maxOffset += rowHeight - padding;
    return {
        height: maxOffset,
        slotItems: slotItems
    };
}
function setHorizontalOffsets(slotItems, items) {
    Object.keys(slotItems).forEach(function (key) {
        var _a = slotItems[key], slot = _a.slot, events = _a.events;
        var rect = slot.rect;
        for (var idx = 0; idx < events.length; idx++) {
            var event_2 = events[idx];
            if (event_2) {
                if (event_2.rect.left === undefined) {
                    event_2.rect.left = slot.rect.left;
                }
                event_2.rect.width += rect.width + BORDER_WIDTH;
            }
        }
    });
    items.forEach(function (item) {
        item.rect.width -= BORDER_WIDTH;
        item.reflow();
    });
}
var matchOverlappingRect = function (left, width) { return function (event) {
    var rect = event.rect;
    if (!rect) {
        return false;
    }
    var before = rect.left < left && rect.left + rect.width < left;
    var after = rect.left > left + width;
    return !before && !after;
}; };
/** @hidden */
var SlotRange = /** @class */ (function () {
    function SlotRange(index) {
        this.index = index;
        this.slotMap = new ItemMap();
        this.itemMap = new ItemMap();
    }
    Object.defineProperty(SlotRange.prototype, "slots", {
        get: function () {
            return this.slotMap.toArray();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlotRange.prototype, "firstSlot", {
        get: function () {
            return this.slotMap.first;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlotRange.prototype, "lastSlot", {
        get: function () {
            return this.slotMap.last;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlotRange.prototype, "items", {
        get: function () {
            return this.itemMap.toArray();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlotRange.prototype, "rect", {
        get: function () {
            var first = this.firstSlot.rect;
            var last = this.lastSlot.rect;
            return {
                left: first.left,
                top: first.top,
                width: last.left - first.left + last.width,
                height: last.top - first.top + last.height
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlotRange.prototype, "start", {
        get: function () {
            var first = this.slotMap.first;
            if (!first) {
                return null;
            }
            return first.start;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlotRange.prototype, "end", {
        get: function () {
            var last = this.slotMap.last;
            if (!last) {
                return null;
            }
            return last.end;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlotRange.prototype, "hasSlots", {
        get: function () {
            return this.slotMap.count > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlotRange.prototype, "hasItems", {
        get: function () {
            return this.itemMap.count > 0;
        },
        enumerable: true,
        configurable: true
    });
    SlotRange.prototype.registerItem = function (component) {
        this.itemMap.addItem(component.item.index, component);
    };
    SlotRange.prototype.unregisterItem = function (component, index) {
        this.itemMap.removeItem(index, component);
    };
    SlotRange.prototype.registerSlot = function (slot) {
        this.slotMap.addItem(slot.id.index, slot);
    };
    SlotRange.prototype.unregisterSlot = function (slot) {
        this.slotMap.removeItem(slot.id.index, slot);
    };
    SlotRange.prototype.layout = function () {
        var items = this.items;
        if (!items.length) {
            return;
        }
        var sorted = orderBy(items, [{ field: "item.startTime", dir: "asc" }, { field: "item.endTime", dir: "desc" }]);
        items.forEach(function (item) {
            item.rect = null;
        });
        var slotItems = {};
        var slots = this.slots;
        // Map each populated slot to the events in it
        sorted.forEach(function (event) { return slots
            .filter(function (slot) { return intersects(event.item.startTime, event.item.endTime, slot.start, slot.end); })
            .forEach(function (slot) {
            var value = slotItems[slot.key] = slotItems[slot.key] || { events: [] };
            value.slot = slot;
            value.events.push(event);
        }); });
        // Break slots into groups with overlapping events.
        var columns = 0;
        var groupSlots = [];
        Object.keys(slotItems).forEach(function (key) {
            var _a = slotItems[key], slot = _a.slot, events = _a.events;
            var count = events.length;
            columns = Math.max(count, columns);
            groupSlots.push(slot);
            var groupEnd = events.every(function (event) {
                return event.item.endTime <= slot.end;
            });
            if (groupEnd) {
                groupSlots.forEach(function (item) { return item.columns = columns; });
                groupSlots = [];
                columns = 0;
            }
        });
        // The maximum number of overlapping events in the group is used to create the same number of columns.
        groupSlots.forEach(function (slot) { return slot.columns = columns; });
        // Compute the event width by dividing the available space in columns.
        // The last event to the right is expanded to fill the remaining space.
        var eventWidths = {};
        Object.keys(slotItems).forEach(function (key) {
            var _a = slotItems[key], slot = _a.slot, events = _a.events;
            var count = events.length;
            var taken = 0;
            events.forEach(function (event, index) {
                var id = event.item.index;
                var last = index === count - 1;
                var size = eventWidths[id] || 1;
                if (last) {
                    size = Math.min(1 - taken, size);
                }
                else {
                    size = Math.min(1 / slot.columns, size);
                    taken += size;
                }
                eventWidths[id] = size;
            });
        });
        // Locate an available column for each event in the group,
        // starting from the top and moving down.
        Object.keys(slotItems).forEach(function (key) {
            var _a = slotItems[key], slot = _a.slot, events = _a.events;
            var count = events.length;
            var fill = 0.9;
            var spacing = 2;
            var startOffset = 2;
            var slotRect = slot.rect;
            var slotLeft = slotRect.left;
            var slotWidth = slotRect.width * fill - (count - 1) * spacing - startOffset;
            var origin = slotLeft + startOffset;
            events.forEach(function (event) {
                var id = event.item.index;
                var width = Math.floor(eventWidths[id] * slotWidth);
                if (!event.rect) {
                    var left = origin;
                    var overlaps = events.find(matchOverlappingRect(left, width));
                    if (overlaps && overlaps.rect.left > origin) {
                        // First column is empty, adjust to fit in it.
                        width = overlaps.rect.left - slotLeft - 2 * spacing;
                    }
                    else {
                        while (overlaps) {
                            left = overlaps.rect.left + overlaps.rect.width + spacing;
                            overlaps = events.find(matchOverlappingRect(left, width));
                        }
                    }
                    event.rect = {
                        top: slotRect.top,
                        left: left,
                        width: width
                    };
                    event.origin = {
                        left: slotLeft,
                        right: slotLeft + slotRect.width
                    };
                }
                // Expand the event to the last group slot
                event.rect.height = slotRect.top + slotRect.height - event.rect.top;
            });
        });
        sorted.forEach(function (event) { return event.reflow(); });
    };
    SlotRange.prototype.initDaySlots = function (rowHeight, eventHeight) {
        var slots = this.slots;
        if (!slots.length) {
            return;
        }
        var _a = initHorizontalSlots(slots, this.items, rowHeight, eventHeight), height = _a.height, slotItems = _a.slotItems;
        this.setSlotsHeight(height);
        this.slotItems = slotItems;
    };
    SlotRange.prototype.setDayOffsets = function () {
        if (!this.itemMap.count || !this.slotItems) {
            return;
        }
        setHorizontalOffsets(this.slotItems, this.items);
        this.slotItems = null;
    };
    SlotRange.prototype.setSlotsHeight = function (height) {
        this.firstSlot.height = height;
    };
    return SlotRange;
}());
export { SlotRange };
/**
 * @hidden
 */
var DayTimeResourceGroup = /** @class */ (function () {
    function DayTimeResourceGroup(index) {
        this.index = index;
        this.dayRanges = [];
        this.timeRanges = [];
    }
    DayTimeResourceGroup.prototype.registerSlot = function (slot) {
        var range = this.slotRange(slot);
        range.registerSlot(slot);
    };
    DayTimeResourceGroup.prototype.unregisterSlot = function (slot) {
        var range = this.slotRange(slot);
        range.unregisterSlot(slot);
        if (!range.hasSlots) {
            var ranges = this.slotRanges(slot);
            delete ranges[slot.id.rangeIndex];
        }
    };
    DayTimeResourceGroup.prototype.registerItem = function (component) {
        var range = this.itemRange(component);
        if (range) {
            range.registerItem(component);
            component.rangeIndex = range.index;
        }
        else {
            component.rangeIndex = undefined;
            component.toggle(false);
        }
    };
    DayTimeResourceGroup.prototype.unregisterItem = function (component, index) {
        if (component.rangeIndex !== undefined) {
            var ranges = component.item.isAllDay ? this.dayRanges : this.timeRanges;
            if (ranges[component.rangeIndex]) {
                ranges[component.rangeIndex].unregisterItem(component, index);
            }
            component.rangeIndex = undefined;
        }
    };
    DayTimeResourceGroup.prototype.forEachDateRange = function (callback) {
        for (var i = 0; i < this.dayRanges.length; i++) {
            callback(this.dayRanges[i]);
        }
    };
    DayTimeResourceGroup.prototype.forEachTimeRange = function (callback) {
        for (var i = 0; i < this.timeRanges.length; i++) {
            callback(this.timeRanges[i]);
        }
    };
    DayTimeResourceGroup.prototype.slotRange = function (slot) {
        var ranges = this.slotRanges(slot);
        var rangeIndex = slot.id.rangeIndex;
        if (!ranges[rangeIndex]) {
            ranges[rangeIndex] = new SlotRange(rangeIndex);
        }
        return ranges[rangeIndex];
    };
    DayTimeResourceGroup.prototype.slotRanges = function (slot) {
        return slot.isDaySlot ? this.dayRanges : this.timeRanges;
    };
    DayTimeResourceGroup.prototype.initTimeSlots = function (rowHeight, eventHeight) {
        var slots = this.slots;
        if (!slots.length) {
            return;
        }
        var _a = initHorizontalSlots(slots, this.items, rowHeight, eventHeight), height = _a.height, slotItems = _a.slotItems;
        this.setSlotsHeight(height);
        this.slotItems = slotItems;
    };
    DayTimeResourceGroup.prototype.setTimelineOffsets = function () {
        var items = this.items;
        if (!this.slotItems || !items.length) {
            return;
        }
        setHorizontalOffsets(this.slotItems, items);
        this.slotItems = null;
    };
    DayTimeResourceGroup.prototype.setSlotsHeight = function (height) {
        //setting the first slot height should be sufficient
        this.timeRanges[0].setSlotsHeight(height);
    };
    Object.defineProperty(DayTimeResourceGroup.prototype, "items", {
        get: function () {
            return this.timeRanges.reduce(function (acc, range) { return acc.concat(range.items); }, []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DayTimeResourceGroup.prototype, "slots", {
        get: function () {
            return this.timeRanges.reduce(function (acc, range) { return acc.concat(range.slots); }, []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DayTimeResourceGroup.prototype, "hasSlots", {
        get: function () {
            return Boolean(this.dayRanges.find(function (range) { return range && range.hasSlots; }) || this.timeRanges.find(function (range) { return range && range.hasSlots; }));
        },
        enumerable: true,
        configurable: true
    });
    DayTimeResourceGroup.prototype.itemRange = function (component) {
        var task = component.item;
        var ranges = task.isAllDay ? this.dayRanges : this.timeRanges;
        return ranges.find(function (r) { return intersects(task.startTime, task.endTime, r.start, r.end); });
    };
    return DayTimeResourceGroup;
}());
export { DayTimeResourceGroup };
/**
 * @hidden
 */
var DayTimeSlotService = /** @class */ (function (_super) {
    tslib_1.__extends(DayTimeSlotService, _super);
    function DayTimeSlotService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DayTimeSlotService.prototype.layoutDays = function (eventHeight) {
        if (eventHeight === void 0) { eventHeight = 25; }
        this.clearEmptyGroups();
        this.groups.forEach(function (group) {
            return group.forEachDateRange(function (range) { return range.slots.forEach(function (slot) {
                slot.element.nativeElement.style.height = '';
            }); });
        });
        var rowHeight = this.groups[0].dayRanges[0].slots[0].height;
        this.groups.forEach(function (group) {
            group.forEachDateRange(function (range) { return range.initDaySlots(rowHeight, eventHeight); });
        });
        this.groups.forEach(function (group) {
            group.forEachDateRange(function (range) { return range.setDayOffsets(); });
        });
    };
    DayTimeSlotService.prototype.layoutTimeline = function (eventHeight) {
        this.clearEmptyGroups();
        this.groups.forEach(function (group) {
            return group.forEachTimeRange(function (range) { return range.slots.forEach(function (slot) {
                slot.element.nativeElement.style.height = '';
            }); });
        });
        var rowHeight = this.groups[0].timeRanges[0].slots[0].height;
        this.groups.forEach(function (group) {
            return group.initTimeSlots(rowHeight, eventHeight);
        });
        this.groups.forEach(function (group) {
            return group.setTimelineOffsets();
        });
    };
    DayTimeSlotService.prototype.layoutTimes = function () {
        this.groups.forEach(function (group) {
            return group.forEachTimeRange(function (range) { return range.layout(); });
        });
    };
    DayTimeSlotService.prototype.forEachDateRange = function (callback) {
        this.groups.forEach(function (group, index) {
            callback(group.dayRanges[0], index);
        });
    };
    DayTimeSlotService.prototype.syncDateRanges = function () {
        var maxHeight = 0;
        this.groups.forEach(function (group) {
            var slot = group.dayRanges[0].firstSlot;
            if (slot) {
                maxHeight = Math.max(slot.rect.height - slot.padding, maxHeight);
            }
        });
        this.groups.forEach(function (group) {
            group.dayRanges[0].setSlotsHeight(maxHeight);
        });
        return maxHeight;
    };
    DayTimeSlotService.prototype.forEachGroup = function (callback) {
        this.groups.forEach(callback);
    };
    DayTimeSlotService.prototype.forEachSlot = function (callback) {
        this.groups.forEach(function (group) {
            group.dayRanges.forEach(function (range) {
                range.slots.forEach(function (slot) { return callback(slot); });
            });
            group.timeRanges.forEach(function (range) {
                range.slots.forEach(function (slot) { return callback(slot); });
            });
        });
    };
    DayTimeSlotService.prototype.createGroup = function (index) {
        return new DayTimeResourceGroup(index);
    };
    DayTimeSlotService.prototype.slotByIndex = function (slotIndex, allDay) {
        if (allDay === void 0) { allDay = false; }
        var _a = slotIndex.split(':').map(function (part) { return parseInt(part, 10); }), resourceIndex = _a[0], rangeIndex = _a[1], index = _a[2];
        return this.groups[resourceIndex][allDay ? 'dayRanges' : 'timeRanges'][rangeIndex].slots[index];
    };
    DayTimeSlotService.prototype.slotByPosition = function (x, y, includeDayRanges) {
        var range;
        if (y < 0) {
            this.groups.find(function (group) {
                range = group.dayRanges.find(function (r) { return rectContainsX(r.rect, x); });
                return range;
            });
            if (range) {
                return range.slots.find(function (slot) { return rectContainsX(slot.rect, x); });
            }
        }
        else {
            this.groups.find(function (group) {
                if (includeDayRanges) {
                    range = group.dayRanges.find(function (r) { return rectContains(r.rect, x, y); });
                }
                if (!range) {
                    range = group.timeRanges.find(function (r) { return rectContains(r.rect, x, y); });
                }
                return range;
            });
            if (range) {
                return range.slots.find(function (slot) { return rectContains(slot.rect, x, y); });
            }
        }
    };
    DayTimeSlotService.prototype.groupSlotByPosition = function (currentSlot, x, y) {
        var group = this.groups[currentSlot.id.resourceIndex];
        var range;
        if (currentSlot.isDaySlot) {
            range = group.dayRanges.find(function (r) { return rectContains(r.rect, x, y); });
        }
        else {
            range = group.timeRanges.find(function (r) { return rectContains(r.rect, x, y); });
        }
        if (range) {
            return range.slots.find(function (slot) { return rectContains(slot.rect, x, y); });
        }
    };
    DayTimeSlotService.prototype.dragRanges = function (currentSlot, offset, timeRanges) {
        var start = new Date(currentSlot.start.getTime() - offset.start);
        var end = new Date(currentSlot.start.getTime() + offset.end);
        var group = this.groups[currentSlot.id.resourceIndex];
        var result;
        if (timeRanges) {
            var slotRanges_1 = [];
            group.timeRanges.forEach(function (range) {
                var slots = range.slots.filter(function (s) { return intersects(start, end, s.start, s.end); });
                if (slots.length) {
                    slotRanges_1.push(slots);
                }
            });
            var lastRange = slotRanges_1[slotRanges_1.length - 1];
            result = [slotRanges_1[0][0], lastRange[lastRange.length - 1]];
        }
        else {
            result = group.slotRange(currentSlot).slots.filter(function (s) { return intersects(start, end, s.start, s.end); });
        }
        return {
            start: start,
            end: end,
            ranges: [result]
        };
    };
    DayTimeSlotService.prototype.resizeRanges = function (currentSlot, task, resizeStart) {
        var group = this.groups[currentSlot.id.resourceIndex];
        var ranges = task.isAllDay ? group.dayRanges : group.timeRanges;
        var result = [];
        var start, end;
        if (resizeStart) {
            start = currentSlot.start.getTime() >= task.endTime.getTime() ?
                new Date(Math.max(task.startTime.getTime(), task.endTime.getTime() - 1)) : currentSlot.start;
            end = task.startTime.getTime() === task.endTime.getTime() ? new Date(task.startTime.getTime() + 1) : task.endTime;
        }
        else {
            start = task.startTime;
            end = new Date(Math.max(currentSlot.end.getTime(), task.startTime.getTime() + 1));
        }
        ranges.forEach(function (range) {
            var slots = range.slots.filter(function (s) { return intersects(start, end, s.start, s.end); });
            if (slots.length) {
                result.push(slots);
            }
        });
        return {
            start: start,
            end: end,
            ranges: result
        };
    };
    DayTimeSlotService.prototype.timePosition = function (date, resourceIndex, vertical) {
        var group = this.groups[resourceIndex];
        var range = group.timeRanges.find(function (r) { return dateInRange(date, r.start, r.end); });
        if (!range) {
            return;
        }
        var slot = range.slots.find(function (s) { return dateInRange(date, s.start, s.end); });
        if (slot) {
            var position = (vertical ? slot.height : slot.width) *
                ((date.getTime() - slot.start.getTime()) / (slot.end.getTime() - slot.start.getTime()));
            return vertical ? slot.rect.top + position : slot.rect.left + position;
        }
    };
    return DayTimeSlotService;
}(BaseSlotService));
export { DayTimeSlotService };
