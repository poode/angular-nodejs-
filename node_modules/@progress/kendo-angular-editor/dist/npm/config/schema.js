"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var prosemirror_model_1 = require("prosemirror-model");
var util_1 = require("../util");
var SLOT = 0; //https://prosemirror.net/docs/guide/#schema.serialization_and_parsing
var commonAttributes = function () {
    return {
        style: { default: null },
        class: { default: null },
        id: { default: null }
    };
};
/**
 * @hidden
 */
var marks = {
    // TODO: Add target.
    // :: MarkSpec A link. Has `href` and `title` attributes. `title`
    // defaults to an empty string. Rendered and parsed as an `<a>`
    // element.
    link: {
        attrs: {
            href: { default: '' },
            title: { default: null }
        },
        inclusive: false,
        parseDOM: [{
                tag: 'a[href]',
                getAttrs: function (dom) { return ({
                    href: dom.getAttribute('href'),
                    title: dom.getAttribute('title')
                }); }
            }],
        toDOM: function (mark) { return [
            'a',
            // Add default value for href. Otherwise the link is not rendered properly(blue with underline)
            Object.assign({}, { href: '' }, util_1.removeEmptyEntries(mark.attrs)),
            SLOT
        ]; }
    },
    // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.
    // Has parse rules that also match `<i>` and `font-style: italic`.
    em: {
        parseDOM: [
            { tag: 'i' },
            { tag: 'em' },
            { style: 'font-style=italic' }
        ],
        toDOM: function () { return ['em', SLOT]; }
    },
    // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules
    // also match `<b>` and `font-weight: bold`.
    strong: {
        parseDOM: [
            { tag: 'strong' },
            // This works around a Google Docs misbehavior where
            // pasted content will be inexplicably wrapped in `<b>`
            // tags with a font-weight normal `{tag: 'b', getAttrs: node => node.style.fontWeight != 'normal' && null}`,
            {
                style: 'font-weight',
                // According to the docs, the value can be a DOM element (for tag rules) or a string (for style rules).
                getAttrs: function (value) { return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null; }
            }
        ],
        toDOM: function () { return ['strong', SLOT]; }
    },
    // :: MarkSpec Code font mark. Represented as a `<code>` element.
    code: {
        parseDOM: [{ tag: 'code' }],
        toDOM: function () { return ['code', SLOT]; }
    },
    // :: MarkSpec An underline mark. Rendered as a `<u>` element.
    // Parse rules also match `text-decoration: underline`.
    underline: {
        parseDOM: [
            { tag: 'u' },
            { style: 'text-decoration=underline' }
        ],
        toDOM: function () { return ['u', SLOT]; }
    },
    // :: MarkSpec A strikethrough mark. Rendered as a `<del>` element.
    // Parse rules also match `<s>`, `<strike>`, `text-decoration: line-through`.
    strikethrough: {
        parseDOM: [
            { tag: 'del' },
            { tag: 's' },
            { tag: 'strike' },
            { style: 'text-decoration=line-through' }
        ],
        toDOM: function () { return ['del', SLOT]; }
    },
    // :: MarkSpec A subscript mark. Rendered as a `<sub>` element.
    // Parse rules also match `vertical-align: sub`.
    subscript: {
        parseDOM: [
            { tag: 'sub' },
            { style: 'vertical-align=sub' }
        ],
        toDOM: function () { return ['sub', SLOT]; }
    },
    // :: MarkSpec A superscript mark. Rendered as a `<sup>` element.
    // Parse rules also match `vertical-align: super`.
    superscript: {
        parseDOM: [
            { tag: 'sup' },
            { style: 'vertical-align=super' }
        ],
        toDOM: function () { return ['sup', SLOT]; }
    }
};
/**
 * @hidden
 */
var nodes = {
    // :: NodeSpec The top level document node.
    doc: {
        content: 'block+'
    },
    // :: NodeSpec A plain textblock paragraph. Represented
    // as a `<p>` element in the DOM.
    paragraph: {
        content: 'inline*',
        group: 'block',
        attrs: tslib_1.__assign({}, commonAttributes()),
        parseDOM: [{
                tag: 'p',
                getAttrs: util_1.serializeDOMAttrs
            }],
        toDOM: function (node) { return util_1.isEmpty(node.attrs) ? ['p', SLOT] : ['p', util_1.removeEmptyEntries(node.attrs), SLOT]; }
    },
    // :: NodeSpec A blockquote (`<blockquote>`) which wraps one or more blocks.
    blockquote: {
        content: 'inline*',
        group: 'block',
        attrs: tslib_1.__assign({}, commonAttributes()),
        defining: true,
        parseDOM: [{ tag: 'blockquote' }],
        toDOM: function (node) { return ['blockquote', util_1.removeEmptyEntries(node.attrs), SLOT]; }
    },
    // :: NodeSpec A horizontal (`<hr>`) rule.
    horizontalRule: {
        group: 'block',
        parseDOM: [{ tag: 'hr' }],
        toDOM: function () { return ['hr']; }
    },
    // :: NodeSpec A heading textblock with a `level` attribute that
    // has to hold a number from 1 to 6. Parsed and serialized as an `<h1>` to
    // an `<h6>` element.
    heading: {
        attrs: tslib_1.__assign({ level: { default: 1 } }, commonAttributes()),
        content: 'inline*',
        group: 'block',
        defining: true,
        parseDOM: [
            { tag: 'h1', attrs: { level: 1 } },
            { tag: 'h2', attrs: { level: 2 } },
            { tag: 'h3', attrs: { level: 3 } },
            { tag: 'h4', attrs: { level: 4 } },
            { tag: 'h5', attrs: { level: 5 } },
            { tag: 'h6', attrs: { level: 6 } }
        ],
        toDOM: function (node) {
            var attrs = util_1.removeEntries(node.attrs, function (key) { return key !== 'level'; });
            return ['h' + node.attrs.level, util_1.removeEmptyEntries(attrs), SLOT];
        }
    },
    // :: NodeSpec A code listing. Prevents marks or non-text inline
    // nodes by default. Represented as a `<pre>` element with a
    // `<code>` element inside.
    codeBlock: {
        content: 'text*',
        marks: '',
        group: 'block',
        code: true,
        defining: true,
        parseDOM: [{
                tag: 'pre',
                preserveWhitespace: 'full'
            }],
        toDOM: function () { return ['pre', ['code', SLOT]]; }
    },
    // :: NodeSpec The text node.
    text: {
        group: 'inline'
    },
    // :: NodeSpec An inline image (`<img>`) node. Supports `src`,
    // `alt`, and `href` attributes. The last two default to an empty
    // string.
    image: {
        inline: true,
        attrs: tslib_1.__assign({}, commonAttributes(), { src: {}, alt: { default: null }, width: { default: null }, height: { default: null } }),
        group: 'inline',
        draggable: true,
        parseDOM: [{
                tag: 'img[src]',
                getAttrs: function (dom) { return ({
                    src: dom.getAttribute('src'),
                    alt: dom.getAttribute('alt'),
                    width: dom.getAttribute('width'),
                    height: dom.getAttribute('height')
                }); }
            }],
        toDOM: function (node) { return ['img', util_1.removeEmptyEntries(node.attrs)]; }
    },
    // :: NodeSpec A hard line break. Represented as a `<br>` element in the DOM.
    hardBreak: {
        inline: true,
        group: 'inline',
        selectable: false,
        parseDOM: [{ tag: 'br' }],
        toDOM: function () { return ['br']; }
    },
    // :: NodeSpec A list item. Represented as a `<li>` element.
    listItem: {
        attrs: tslib_1.__assign({}, commonAttributes()),
        content: 'paragraph block*',
        marks: '_',
        parseDOM: [{ tag: 'li' }],
        toDOM: function (node) { return ['li', util_1.removeEmptyEntries(node.attrs), SLOT]; }
    },
    // :: NodeSpec An ordered list. Represented as an `<ol>` element.
    // Has a single `order` attribute which determines the number at which
    // the list starts counting. Defaults to 1.
    orderedList: {
        attrs: {
            order: {
                default: 1
            }
        },
        content: 'listItem+',
        group: 'block',
        parseDOM: [{
                tag: 'ol',
                getAttrs: function (dom) { return ({
                    order: dom.hasAttribute('start') ? parseInt(dom.getAttribute('start'), 10) : 1
                }); }
            }],
        toDOM: function (node) { return (node.attrs.order === 1 ? ['ol', SLOT] : ['ol', { start: node.attrs.order }, SLOT]); }
    },
    // :: NodeSec An unordered list. Represented as a `<ul>` element.
    bulletList: {
        content: 'listItem+',
        group: 'block',
        parseDOM: [{ tag: 'ul' }],
        toDOM: function () { return ['ul', SLOT]; }
    }
};
/**
 * @hidden
 */
exports.schema = new prosemirror_model_1.Schema({
    nodes: nodes,
    marks: marks
});
