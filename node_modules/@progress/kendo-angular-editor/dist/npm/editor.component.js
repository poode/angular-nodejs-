"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var forms_1 = require("@angular/forms");
var fromEvent_1 = require("rxjs/observable/fromEvent");
var map_1 = require("rxjs/operators/map");
var filter_1 = require("rxjs/operators/filter");
var kendo_angular_toolbar_1 = require("@progress/kendo-angular-toolbar");
var kendo_angular_dialog_1 = require("@progress/kendo-angular-dialog");
var prosemirror_view_1 = require("prosemirror-view");
var prosemirror_commands_1 = require("prosemirror-commands");
var prosemirror_state_1 = require("prosemirror-state");
var prosemirror_keymap_1 = require("prosemirror-keymap");
var prosemirror_history_1 = require("prosemirror-history");
var schema_1 = require("./config/schema");
var keymap_1 = require("./config/keymap");
var commands_1 = require("./config/commands");
var align_rules_1 = require("./config/align-rules");
var link_dialog_component_1 = require("./dialogs/link-dialog.component");
var source_dialog_component_1 = require("./dialogs/source-dialog.component");
var image_dialog_component_1 = require("./dialogs/image-dialog.component");
var prosemirror_utils_1 = require("./prosemirror-utils");
function updateToolBar(_a) {
    var state = _a.state;
    return {
        //marks
        bold: prosemirror_utils_1.isMarkActive(state, schema_1.schema.marks.strong),
        italic: prosemirror_utils_1.isMarkActive(state, schema_1.schema.marks.em),
        underline: prosemirror_utils_1.isMarkActive(state, schema_1.schema.marks.underline),
        strikethrough: prosemirror_utils_1.isMarkActive(state, schema_1.schema.marks.strikethrough),
        link: prosemirror_utils_1.isMarkActive(state, schema_1.schema.marks.link),
        subscript: prosemirror_utils_1.isMarkActive(state, schema_1.schema.marks.subscript),
        superscript: prosemirror_utils_1.isMarkActive(state, schema_1.schema.marks.superscript),
        //nodes
        format: prosemirror_utils_1.activeNodeName(state),
        insertOrderedList: prosemirror_utils_1.isInListOfType(state, schema_1.schema.nodes.orderedList),
        insertUnorderedList: prosemirror_utils_1.isInListOfType(state, schema_1.schema.nodes.bulletList),
        indent: prosemirror_utils_1.canIndent(state, schema_1.schema.nodes.listItem),
        outdent: prosemirror_utils_1.canOutdent(state, schema_1.schema.nodes.listItem),
        alignLeft: prosemirror_utils_1.isAligned(state, align_rules_1.alignLeftRules),
        alignCenter: prosemirror_utils_1.isAligned(state, align_rules_1.alignCenterRules),
        alignRight: prosemirror_utils_1.isAligned(state, align_rules_1.alignRightRules),
        alignJustify: prosemirror_utils_1.isAligned(state, align_rules_1.alignRemoveRules),
        //history
        undo: !prosemirror_history_1.undo(state),
        redo: !prosemirror_history_1.redo(state),
        //selection
        noSelection: state.selection.empty
    };
}
var editorDialogs = {
    createLink: {
        content: link_dialog_component_1.LinkDialogComponent
    },
    viewSource: {
        content: source_dialog_component_1.SourceDialogComponent,
        width: 500,
        height: 400
    },
    insertImage: {
        content: image_dialog_component_1.ImageDialogComponent
    }
};
var EMPTY_PARAGRAPH = '<p></p>';
/**
 * Represents the [Kendo UI Editor component for Angular]({% slug overview_editor %}).
 */
var EditorComponent = /** @class */ (function () {
    function EditorComponent(element, dialogService) {
        this.element = element;
        this.dialogService = dialogService;
        /**
         * Fires each time the value of the Editor is changed upon user interaction&mdash;
         * for example, when the component is blurred or the value is updated through the `viewSource` dialog.
         * When the value of the Editor is programmatically changed through its API (`ngModel`) or form binding (`formControl`),
         * the `valueChange` event is not triggered because it might cause a mix-up with the
         * built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new core_1.EventEmitter();
        /**
         * @hidden
         */
        this.stateChange = new core_1.EventEmitter();
        this.onChangeCallback = function (_) { }; // tslint:disable-line:no-empty
        this.onTouchedCallback = function (_) { }; // tslint:disable-line:no-empty
    }
    Object.defineProperty(EditorComponent.prototype, "value", {
        get: function () {
            var value = this.view ? this.getSource() : this._value;
            if (value === EMPTY_PARAGRAPH) {
                return this._value ? '' : this._value;
            }
            else {
                return value;
            }
        },
        /**
         * Sets the value of the Editor ([see example]({% slug overview_editor %}#toc-basic-usage)).
         */
        set: function (value) {
            this._value = value;
            this._previousValue = value;
            if (this.view) {
                this.exec('setHTML', this._value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorComponent.prototype, "className", {
        get: function () {
            return 'k-widget k-editor';
        },
        enumerable: true,
        configurable: true
    });
    EditorComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        var that = this;
        var containerNativeElement = this.container.element.nativeElement;
        var contentNode = prosemirror_utils_1.createContentNode(this.value);
        var state = prosemirror_state_1.EditorState.create({
            schema: schema_1.schema,
            doc: contentNode,
            plugins: [
                prosemirror_history_1.history(),
                prosemirror_keymap_1.keymap(keymap_1.buildKeymap(schema_1.schema)),
                prosemirror_keymap_1.keymap({
                    'Mod-z': prosemirror_history_1.undo,
                    'Mod-y': prosemirror_history_1.redo
                }),
                prosemirror_keymap_1.keymap(prosemirror_commands_1.baseKeymap)
            ]
        });
        this.view = new prosemirror_view_1.EditorView(containerNativeElement, {
            state: state,
            dispatchTransaction: function (tr) {
                // `this` is bound to the view instance.
                this.updateState(this.state.apply(tr));
                that.stateChange.emit(updateToolBar(this));
                // When the user utilizes keyboard shortcuts&mdash;for example, `Ctrl`+`b`&mdash;
                // `tr.docChanged` is `true` and the toolbar is not updated.
                // A possible future solution is to move the keymaps to the service.
                // if (!tr.docChanged) {
                //     that.stateChange.emit(updateToolBar(that.view));
                // }
            }
        });
        this.subs = fromEvent_1.fromEvent(this.container.element.nativeElement, 'keyup').pipe(map_1.map(function (e) { return e.keyCode; }), filter_1.filter(function (code) { return code === 121; }), // F10
        map_1.map(function () { return _this.userToolBar || _this.defaultToolbar; }))
            .subscribe(function (toolbar) { return toolbar.nativeElement.focus(); });
        var blur$ = fromEvent_1.fromEvent(this.element.nativeElement, 'focusout').pipe(filter_1.filter(function (event) { return !_this.element.nativeElement.contains(event.relatedTarget); }));
        this.subs.add(
        //on blur & new value
        blur$.pipe(map_1.map(function () { return _this.value; }), filter_1.filter(function (value) { return !prosemirror_utils_1.hasSameMarkup(value, that._previousValue); }))
            .subscribe(function (value) {
            _this._previousValue = value;
            _this.onChangeCallback(value);
            _this.valueChange.emit(value);
        }));
        this.subs.add(
        //on every blur
        blur$.subscribe(function () { return _this.onTouchedCallback(); }));
    };
    /**
     * Executes a command on the currently selected text.
     *
     * @param {EditorCommand} commandName - The command that will be executed.
     * @param {any} attr - Optional parameters for the command. Apart from the following list, the parameters do not expect specific attributes when you call them:
     * - `format` - Accepts an object with the `tag` property.
     * The supported tags are `p`, `blockquote`, and any of the `h1` to `h6` heading tags.
     * - `createLink` - Accepts an object with the `href`, `title`, and `target` properties. The `href` property is mandatory.
     * - `setHTML` - Accepts a `string` parameter.
     *
     * @example
     * ```ts-no-run
     * // Toggles the bold styling.
     * editor.exec('bold');
     *
     * // Creates a bullet list.
     * editor.exec('insertUnorderedList');
     *
     * // Creates a link.
     * editor.exec('createLink', { href: 'www.progress.com', title: 'Progress', target: 'window' });
     *
     * // Changes the format of a text block.
     * editor.exec('format', { tag: 'h2' });
     *
     * // Changes the content of the Editor.
     * editor.exec('setHTML', '<p>HTML content</p>');
     * ```
     */
    EditorComponent.prototype.exec = function (commandName, attr) {
        // Finds a command and applies the attributes.
        var command = commands_1.editorCommands[commandName](attr);
        // Executes a ProseMirror command.
        command(this.view.state, this.view.dispatch, this.view);
        // See the `dispatchTransaction` comments.
        // this.stateChange.emit(updateToolBar(this.view));
    };
    /**
     * Opens a dialog.
     * @param {DialogCommand} dialogName - The name of the dialog that will open.
     *
     * The supported values are:
     * * `createLink`
     * * `viewSource`
     *
     * @example
     * ```ts-no-run
     * // Opens a `createLink` dialog.
     * editor.openDialog('createLink');
     *
     * // Opens a `viewSource` dialog.
     * editor.exec('viewSource');
     * ```
     */
    EditorComponent.prototype.openDialog = function (dialogName) {
        var dialog = editorDialogs[dialogName];
        var dialogRef = this.dialogService.open(dialog);
        dialogRef.content.instance.editor = this;
        dialogRef.content.instance.setData(this.view.state);
    };
    /**
     * Manually focus the Editor.
     */
    EditorComponent.prototype.focus = function () {
        this.view.focus();
    };
    /**
     * Manually blur the Editor.
     */
    EditorComponent.prototype.blur = function () {
        this.view.dom.blur();
    };
    /**
     * @hidden
     */
    EditorComponent.prototype.getSource = function () {
        return prosemirror_utils_1.getHTML(this.view.state);
    };
    EditorComponent.prototype.ngOnDestroy = function () {
        this.subs.unsubscribe();
    };
    /**
     * @hidden
     */
    EditorComponent.prototype.writeValue = function (value) {
        // To avoid confusion, non-existent values are always undefined.
        this.value = value === null ? undefined : value;
    };
    /**
     * @hidden
     */
    EditorComponent.prototype.registerOnChange = function (fn) {
        this.onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    EditorComponent.prototype.registerOnTouched = function (fn) {
        this.onTouchedCallback = fn;
    };
    EditorComponent.decorators = [
        { type: core_1.Component, args: [{
                    selector: 'kendo-editor',
                    providers: [
                        kendo_angular_dialog_1.DialogService,
                        {
                            provide: forms_1.NG_VALUE_ACCESSOR,
                            useExisting: core_1.forwardRef(function () { return EditorComponent; }),
                            multi: true
                        }
                    ],
                    template: "\n        <ng-content select=\"kendo-toolbar\"></ng-content>\n        <kendo-toolbar *ngIf=\"!userToolBar\" #defaultToolbar>\n            <kendo-toolbar-buttongroup>\n                <kendo-toolbar-button kendoEditorButton=\"bold\"></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorButton=\"italic\"></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorButton=\"underline\"></kendo-toolbar-button>\n            </kendo-toolbar-buttongroup>\n            <kendo-toolbar-dropdownlist kendoEditorDropDown=\"format\"></kendo-toolbar-dropdownlist>\n            <kendo-toolbar-buttongroup>\n                <kendo-toolbar-button kendoEditorButton=\"insertUnorderedList\"></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorButton=\"insertOrderedList\"></kendo-toolbar-button>\n            </kendo-toolbar-buttongroup>\n            <!-- <kendo-toolbar-dialog kendoEditorCommand=\"createLink\"></kendo-toolbar-dialog> -->\n        </kendo-toolbar>\n        <div #content class=\"k-content\" style=\"height: 300px;\"></div>\n        <div kendoDialogContainer></div>\n    ",
                    styles: ["\n        >>> .k-content > .ProseMirror {\n            height: 100%;\n            width: 100%;\n            box-sizing: border-box;\n            outline: none;\n            overflow: scroll;\n        }\n    "]
                },] },
    ];
    /** @nocollapse */
    EditorComponent.ctorParameters = function () { return [
        { type: core_1.ElementRef, },
        { type: kendo_angular_dialog_1.DialogService, },
    ]; };
    EditorComponent.propDecorators = {
        'value': [{ type: core_1.Input },],
        'valueChange': [{ type: core_1.Output },],
        'className': [{ type: core_1.HostBinding, args: ['class',] },],
        'userToolBar': [{ type: core_1.ContentChild, args: [kendo_angular_toolbar_1.ToolBarComponent, { read: core_1.ElementRef },] },],
        'container': [{ type: core_1.ViewChild, args: ['content', { read: core_1.ViewContainerRef },] },],
        'defaultToolbar': [{ type: core_1.ViewChild, args: ['defaultToolbar', { read: core_1.ElementRef },] },],
    };
    return EditorComponent;
}());
exports.EditorComponent = EditorComponent;
