import { Component, HostBinding, ViewChild, ContentChild, ViewContainerRef, Output, ElementRef, EventEmitter, forwardRef, Input } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { fromEvent } from 'rxjs/observable/fromEvent';
import { map } from 'rxjs/operators/map';
import { filter } from 'rxjs/operators/filter';
import { ToolBarComponent } from '@progress/kendo-angular-toolbar';
import { DialogService } from '@progress/kendo-angular-dialog';
import { EditorView } from 'prosemirror-view';
import { baseKeymap } from 'prosemirror-commands';
import { EditorState } from 'prosemirror-state';
import { keymap } from 'prosemirror-keymap';
import { history, undo, redo } from 'prosemirror-history';
import { schema } from './config/schema';
import { buildKeymap } from './config/keymap';
import { editorCommands } from './config/commands';
import { alignRightRules, alignCenterRules, alignRemoveRules, alignLeftRules } from './config/align-rules';
import { LinkDialogComponent } from './dialogs/link-dialog.component';
import { SourceDialogComponent } from './dialogs/source-dialog.component';
import { ImageDialogComponent } from './dialogs/image-dialog.component';
import { isMarkActive, activeNodeName, canIndent, canOutdent, getHTML, createContentNode, hasSameMarkup, isInListOfType, isAligned } from './prosemirror-utils';
function updateToolBar(_a) {
    var state = _a.state;
    return {
        //marks
        bold: isMarkActive(state, schema.marks.strong),
        italic: isMarkActive(state, schema.marks.em),
        underline: isMarkActive(state, schema.marks.underline),
        strikethrough: isMarkActive(state, schema.marks.strikethrough),
        link: isMarkActive(state, schema.marks.link),
        subscript: isMarkActive(state, schema.marks.subscript),
        superscript: isMarkActive(state, schema.marks.superscript),
        //nodes
        format: activeNodeName(state),
        insertOrderedList: isInListOfType(state, schema.nodes.orderedList),
        insertUnorderedList: isInListOfType(state, schema.nodes.bulletList),
        indent: canIndent(state, schema.nodes.listItem),
        outdent: canOutdent(state, schema.nodes.listItem),
        alignLeft: isAligned(state, alignLeftRules),
        alignCenter: isAligned(state, alignCenterRules),
        alignRight: isAligned(state, alignRightRules),
        alignJustify: isAligned(state, alignRemoveRules),
        //history
        undo: !undo(state),
        redo: !redo(state),
        //selection
        noSelection: state.selection.empty
    };
}
var editorDialogs = {
    createLink: {
        content: LinkDialogComponent
    },
    viewSource: {
        content: SourceDialogComponent,
        width: 500,
        height: 400
    },
    insertImage: {
        content: ImageDialogComponent
    }
};
var EMPTY_PARAGRAPH = '<p></p>';
/**
 * Represents the [Kendo UI Editor component for Angular]({% slug overview_editor %}).
 */
var EditorComponent = /** @class */ (function () {
    function EditorComponent(element, dialogService) {
        this.element = element;
        this.dialogService = dialogService;
        /**
         * Fires each time the value of the Editor is changed upon user interaction&mdash;
         * for example, when the component is blurred or the value is updated through the `viewSource` dialog.
         * When the value of the Editor is programmatically changed through its API (`ngModel`) or form binding (`formControl`),
         * the `valueChange` event is not triggered because it might cause a mix-up with the
         * built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.stateChange = new EventEmitter();
        this.onChangeCallback = function (_) { }; // tslint:disable-line:no-empty
        this.onTouchedCallback = function (_) { }; // tslint:disable-line:no-empty
    }
    Object.defineProperty(EditorComponent.prototype, "value", {
        get: function () {
            var value = this.view ? this.getSource() : this._value;
            if (value === EMPTY_PARAGRAPH) {
                return this._value ? '' : this._value;
            }
            else {
                return value;
            }
        },
        /**
         * Sets the value of the Editor ([see example]({% slug overview_editor %}#toc-basic-usage)).
         */
        set: function (value) {
            this._value = value;
            this._previousValue = value;
            if (this.view) {
                this.exec('setHTML', this._value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorComponent.prototype, "className", {
        get: function () {
            return 'k-widget k-editor';
        },
        enumerable: true,
        configurable: true
    });
    EditorComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        var that = this;
        var containerNativeElement = this.container.element.nativeElement;
        var contentNode = createContentNode(this.value);
        var state = EditorState.create({
            schema: schema,
            doc: contentNode,
            plugins: [
                history(),
                keymap(buildKeymap(schema)),
                keymap({
                    'Mod-z': undo,
                    'Mod-y': redo
                }),
                keymap(baseKeymap)
            ]
        });
        this.view = new EditorView(containerNativeElement, {
            state: state,
            dispatchTransaction: function (tr) {
                // `this` is bound to the view instance.
                this.updateState(this.state.apply(tr));
                that.stateChange.emit(updateToolBar(this));
                // When the user utilizes keyboard shortcuts&mdash;for example, `Ctrl`+`b`&mdash;
                // `tr.docChanged` is `true` and the toolbar is not updated.
                // A possible future solution is to move the keymaps to the service.
                // if (!tr.docChanged) {
                //     that.stateChange.emit(updateToolBar(that.view));
                // }
            }
        });
        this.subs = fromEvent(this.container.element.nativeElement, 'keyup').pipe(map(function (e) { return e.keyCode; }), filter(function (code) { return code === 121; }), // F10
        map(function () { return _this.userToolBar || _this.defaultToolbar; }))
            .subscribe(function (toolbar) { return toolbar.nativeElement.focus(); });
        var blur$ = fromEvent(this.element.nativeElement, 'focusout').pipe(filter(function (event) { return !_this.element.nativeElement.contains(event.relatedTarget); }));
        this.subs.add(
        //on blur & new value
        blur$.pipe(map(function () { return _this.value; }), filter(function (value) { return !hasSameMarkup(value, that._previousValue); }))
            .subscribe(function (value) {
            _this._previousValue = value;
            _this.onChangeCallback(value);
            _this.valueChange.emit(value);
        }));
        this.subs.add(
        //on every blur
        blur$.subscribe(function () { return _this.onTouchedCallback(); }));
    };
    /**
     * Executes a command on the currently selected text.
     *
     * @param {EditorCommand} commandName - The command that will be executed.
     * @param {any} attr - Optional parameters for the command. Apart from the following list, the parameters do not expect specific attributes when you call them:
     * - `format` - Accepts an object with the `tag` property.
     * The supported tags are `p`, `blockquote`, and any of the `h1` to `h6` heading tags.
     * - `createLink` - Accepts an object with the `href`, `title`, and `target` properties. The `href` property is mandatory.
     * - `setHTML` - Accepts a `string` parameter.
     *
     * @example
     * ```ts-no-run
     * // Toggles the bold styling.
     * editor.exec('bold');
     *
     * // Creates a bullet list.
     * editor.exec('insertUnorderedList');
     *
     * // Creates a link.
     * editor.exec('createLink', { href: 'www.progress.com', title: 'Progress', target: 'window' });
     *
     * // Changes the format of a text block.
     * editor.exec('format', { tag: 'h2' });
     *
     * // Changes the content of the Editor.
     * editor.exec('setHTML', '<p>HTML content</p>');
     * ```
     */
    EditorComponent.prototype.exec = function (commandName, attr) {
        // Finds a command and applies the attributes.
        var command = editorCommands[commandName](attr);
        // Executes a ProseMirror command.
        command(this.view.state, this.view.dispatch, this.view);
        // See the `dispatchTransaction` comments.
        // this.stateChange.emit(updateToolBar(this.view));
    };
    /**
     * Opens a dialog.
     * @param {DialogCommand} dialogName - The name of the dialog that will open.
     *
     * The supported values are:
     * * `createLink`
     * * `viewSource`
     *
     * @example
     * ```ts-no-run
     * // Opens a `createLink` dialog.
     * editor.openDialog('createLink');
     *
     * // Opens a `viewSource` dialog.
     * editor.exec('viewSource');
     * ```
     */
    EditorComponent.prototype.openDialog = function (dialogName) {
        var dialog = editorDialogs[dialogName];
        var dialogRef = this.dialogService.open(dialog);
        dialogRef.content.instance.editor = this;
        dialogRef.content.instance.setData(this.view.state);
    };
    /**
     * Manually focus the Editor.
     */
    EditorComponent.prototype.focus = function () {
        this.view.focus();
    };
    /**
     * Manually blur the Editor.
     */
    EditorComponent.prototype.blur = function () {
        this.view.dom.blur();
    };
    /**
     * @hidden
     */
    EditorComponent.prototype.getSource = function () {
        return getHTML(this.view.state);
    };
    EditorComponent.prototype.ngOnDestroy = function () {
        this.subs.unsubscribe();
    };
    /**
     * @hidden
     */
    EditorComponent.prototype.writeValue = function (value) {
        // To avoid confusion, non-existent values are always undefined.
        this.value = value === null ? undefined : value;
    };
    /**
     * @hidden
     */
    EditorComponent.prototype.registerOnChange = function (fn) {
        this.onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    EditorComponent.prototype.registerOnTouched = function (fn) {
        this.onTouchedCallback = fn;
    };
    EditorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'kendo-editor',
                    providers: [
                        DialogService,
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(function () { return EditorComponent; }),
                            multi: true
                        }
                    ],
                    template: "\n        <ng-content select=\"kendo-toolbar\"></ng-content>\n        <kendo-toolbar *ngIf=\"!userToolBar\" #defaultToolbar>\n            <kendo-toolbar-buttongroup>\n                <kendo-toolbar-button kendoEditorButton=\"bold\"></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorButton=\"italic\"></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorButton=\"underline\"></kendo-toolbar-button>\n            </kendo-toolbar-buttongroup>\n            <kendo-toolbar-dropdownlist kendoEditorDropDown=\"format\"></kendo-toolbar-dropdownlist>\n            <kendo-toolbar-buttongroup>\n                <kendo-toolbar-button kendoEditorButton=\"insertUnorderedList\"></kendo-toolbar-button>\n                <kendo-toolbar-button kendoEditorButton=\"insertOrderedList\"></kendo-toolbar-button>\n            </kendo-toolbar-buttongroup>\n            <!-- <kendo-toolbar-dialog kendoEditorCommand=\"createLink\"></kendo-toolbar-dialog> -->\n        </kendo-toolbar>\n        <div #content class=\"k-content\" style=\"height: 300px;\"></div>\n        <div kendoDialogContainer></div>\n    ",
                    styles: ["\n        >>> .k-content > .ProseMirror {\n            height: 100%;\n            width: 100%;\n            box-sizing: border-box;\n            outline: none;\n            overflow: scroll;\n        }\n    "]
                },] },
    ];
    /** @nocollapse */
    EditorComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: DialogService, },
    ]; };
    EditorComponent.propDecorators = {
        'value': [{ type: Input },],
        'valueChange': [{ type: Output },],
        'className': [{ type: HostBinding, args: ['class',] },],
        'userToolBar': [{ type: ContentChild, args: [ToolBarComponent, { read: ElementRef },] },],
        'container': [{ type: ViewChild, args: ['content', { read: ViewContainerRef },] },],
        'defaultToolbar': [{ type: ViewChild, args: ['defaultToolbar', { read: ElementRef },] },],
    };
    return EditorComponent;
}());
export { EditorComponent };
