import { Node, DOMParser, DOMSerializer, Fragment, Slice } from 'prosemirror-model';
import { TextSelection, NodeSelection, AllSelection } from 'prosemirror-state';
import { toggleMark, setBlockType } from 'prosemirror-commands';
import { ReplaceAroundStep } from 'prosemirror-transform';
import { sinkListItem, liftListItem } from 'prosemirror-schema-list';
import { schema } from './config/schema';
import { safeString, first, last, unique } from './util';
var _a = schema.nodes, blockquote = _a.blockquote, bulletList = _a.bulletList, doc = _a.doc, heading = _a.heading, listItem = _a.listItem, orderedList = _a.orderedList, paragraph = _a.paragraph, image = _a.image;
var getTypeName = function (n) {
    return n instanceof Node ? n.type.name : n.name;
};
var isListType = function (node) {
    var nodeName = typeof node === 'string' ? node : getTypeName(node);
    return nodeName === getTypeName(orderedList) || nodeName === getTypeName(bulletList);
};
var getListTypeFromPos = function (pos) {
    return Array.from(new Array(pos.depth), function (_, index) { return pos.depth - index; })
        .map(function (depth) { return pos.node(depth); })
        .map(getTypeName)
        .find(isListType);
};
/**
 * @hidden
 */
export function isMarkActive(state, markType) {
    var _a = state.selection, from = _a.from, $from = _a.$from, to = _a.to, empty = _a.empty;
    if (empty) {
        return !!markType.isInSet(state.storedMarks || $from.marks());
    }
    else {
        return !!state.doc.rangeHasMark(from, to, markType);
    }
}
/**
 * @hidden
 */
export function isNodeActive(state, nodeType, attrs) {
    var parent = findParentNode(function (node) { return getTypeName(node) === getTypeName(nodeType); })(state.selection);
    if (!parent || (attrs && !Object.keys(attrs).length)) {
        return !!parent;
    }
    return parent.node.hasMarkup(nodeType, attrs);
}
/**
 * @hidden
 */
export var isInListOfType = function (_a, nodeType) {
    var selection = _a.selection;
    var $anchor = selection.$anchor, $head = selection.$head;
    var topNodes = [];
    var anchorParentName = getListTypeFromPos($anchor);
    var headParentName = getListTypeFromPos($head);
    selection.content().content.descendants(function (n) {
        topNodes = topNodes.concat([n]);
        return false;
    });
    var nonListTopNodes = topNodes.filter(function (n) {
        return (getTypeName(n) !== getTypeName(bulletList)) && (getTypeName(n) !== getTypeName(orderedList));
    });
    // no selection
    if (selection instanceof TextSelection && selection.$cursor) {
        return getListTypeFromPos(selection.$cursor) === nodeType.name;
    }
    var hasSingleUniqueTopNode = unique(topNodes.map(getTypeName)).length === 1;
    // with selection
    if (nonListTopNodes.length > 0 || !hasSingleUniqueTopNode) {
        return false;
    }
    // from this point on we have guaranteed that the top nodes are all of the same LIST type
    // same top list node
    var node = first(topNodes);
    var listChildNodes = [getTypeName(node)];
    node.descendants(function (childNode) {
        if (isListType(childNode)) {
            listChildNodes = listChildNodes.concat([getTypeName(childNode)]);
        }
    });
    if (last(listChildNodes) !== nodeType.name) {
        return false;
    }
    return anchorParentName === headParentName && anchorParentName === nodeType.name;
};
/**
 * @hidden
 */
export function activeNodeName(state) {
    var node;
    if (state.selection instanceof AllSelection) {
        node = state.doc;
    }
    else {
        var $anchor = state.selection.$anchor;
        var blockNode = $anchor.node($anchor.blockRange().depth);
        var isDoc = getTypeName(blockNode) === getTypeName(doc);
        node = isDoc ? $anchor.node() : blockNode;
    }
    return {
        name: getTypeName(node),
        tag: getNodeTag(node)
    };
}
/**
 * @hidden
 */
function getNodeTag(node) {
    var parseRules = node.type.spec.parseDOM;
    var nodeAttrs = node.attrs;
    var parseRule;
    if (parseRules && parseRules.length) {
        if (parseRules.length === 1) {
            parseRule = parseRules[0];
        }
        else {
            parseRule = parseRules.find(function (rule) {
                //TODO: refactor this
                return JSON.stringify(rule.attrs) === JSON.stringify(nodeAttrs);
            });
        }
    }
    if (parseRule) {
        return parseRule.tag;
    }
}
/**
 * @hidden
 */
export function canIndent(state, nodeType) {
    return isNodeActive(state, nodeType) && sinkListItem(nodeType)(state);
}
/**
 * @hidden
 */
export function canOutdent(state, nodeType) {
    var isNestedInOL = !!findNthParentNodeOfType(orderedList, 2)(state.selection);
    var isNestedInUL = !!findNthParentNodeOfType(bulletList, 2)(state.selection);
    return isNodeActive(state, nodeType) && (isNestedInOL || isNestedInUL) && liftListItem(nodeType)(state);
}
/**
 * @hidden
 */
export function findParentNode(predicate) {
    return function (selection) {
        var $from = selection.$from;
        for (var i = $from.depth; i > 0; i--) {
            var node = $from.node(i);
            if (predicate(node)) {
                return { depth: i, node: node };
            }
        }
    };
}
/**
 * @hidden
 */
export function findNthParentNode(predicate, depth) {
    if (depth === void 0) { depth = 1; }
    return function (selection) {
        var $from = selection.$from;
        for (var i = $from.depth; i > 0; i--) {
            var node = $from.node(i);
            if (predicate(node)) {
                depth = depth - 1;
                if (depth === 0) {
                    return { depth: i, node: node };
                }
            }
        }
    };
}
/**
 * @hidden
 */
export function findNthParentNodeOfType(nodeType, depth) {
    if (depth === void 0) { depth = 1; }
    return function (selection) {
        return findNthParentNode(function (node) { return getTypeName(node) === getTypeName(nodeType); }, depth)(selection);
    };
}
/**
 * @hidden
 */
export var getMark = function (state, markType) {
    var _a = state.selection, from = _a.from, $from = _a.$from, to = _a.to, empty = _a.empty;
    var stateDoc = state.doc;
    var mark;
    if (empty) {
        mark = markType.isInSet(state.storedMarks || $from.marks());
    }
    else {
        stateDoc.nodesBetween(from, to, function (node) {
            if (node.isInline && !mark) {
                mark = markType.isInSet(node.marks);
            }
        });
    }
    return mark;
};
/**
 * @hidden
 */
export var getNodeFromSelection = function (state) {
    if (state.selection instanceof NodeSelection) {
        return state.selection.node;
    }
};
/**
 * @hidden
 */
export function getMarkRange($cursor, markType) {
    var parentNode = $cursor.parent;
    var cursorNodeIndex = $cursor.index();
    var mark = parentNode.child(cursorNodeIndex).marks.find(function (m) { return m.type === markType; });
    var childCount = parentNode.childCount;
    var start = $cursor.pos - $cursor.textOffset, end = parentNode.child(cursorNodeIndex).nodeSize, index, nodeSize;
    index = cursorNodeIndex - 1;
    while (index >= 0 && mark.isInSet(parentNode.child(index).marks)) {
        nodeSize = parentNode.child(index).nodeSize;
        end += nodeSize;
        start -= nodeSize;
        index -= 1;
    }
    index = cursorNodeIndex + 1;
    while (index < childCount && mark.isInSet(parentNode.child(index).marks)) {
        end += parentNode.child(index).nodeSize;
        index += 1;
    }
    return { from: start, to: start + end };
}
/**
 * @hidden
 */
export var removeMark = function (markType) { return function (state, dispatch) {
    var _a = state.selection, from = _a.from, to = _a.to, $cursor = _a.$cursor;
    if ($cursor) {
        var resolvedRange = getMarkRange($cursor, markType);
        dispatch(state.tr.removeMark(resolvedRange.from, resolvedRange.to, markType));
    }
    else {
        dispatch(state.tr.removeMark(from, to, markType));
    }
}; };
/**
 * @hidden
 */
var modifyMark = function (markType, attrs) { return function (state, dispatch) {
    var tr = state.tr;
    var _a = state.selection, $cursor = _a.$cursor, from = _a.from, to = _a.to;
    if (!$cursor) {
        tr.doc.nodesBetween(from, to, function (node, pos) {
            if (node.isInline && markType.isInSet(node.marks)) {
                tr.removeMark(pos, pos + node.nodeSize, markType);
                tr.addMark(pos, pos + node.nodeSize, markType.create(attrs));
                dispatch(tr);
            }
        });
    }
    else {
        var parentNode = $cursor.parent;
        var cursorNodeIndex = $cursor.index();
        var mark = parentNode.child(cursorNodeIndex).marks.find(function (m) { return m.type === markType; });
        var childCount = parentNode.childCount;
        var markStart = $cursor.pos - $cursor.textOffset, markSize = parentNode.child(cursorNodeIndex).nodeSize, index = void 0, nodeSize = void 0;
        index = cursorNodeIndex - 1;
        while (index >= 0 && mark.isInSet(parentNode.child(index).marks)) {
            nodeSize = parentNode.child(index).nodeSize;
            markSize += nodeSize;
            markStart -= nodeSize;
            index -= 1;
        }
        index = cursorNodeIndex + 1;
        while (index < childCount && mark.isInSet(parentNode.child(index).marks)) {
            markSize += parentNode.child(index).nodeSize;
            index += 1;
        }
        tr.removeMark(markStart, markStart + markSize, markType);
        tr.addMark(markStart, markStart + markSize, markType.create(attrs));
        dispatch(tr);
    }
}; };
/**
 * @hidden
 */
export var toggleBold = toggleMark(schema.marks.strong);
/**
 * @hidden
 */
export var toggleItalic = toggleMark(schema.marks.em);
/**
 * @hidden
 */
export var toggleUnderline = toggleMark(schema.marks.underline);
/**
 * @hidden
 */
export var toggleStrikethrough = toggleMark(schema.marks.strikethrough);
/**
 * @hidden
 */
export var toggleSubscript = toggleMark(schema.marks.subscript);
/**
 * @hidden
 */
export var toggleSuperscript = toggleMark(schema.marks.superscript);
/**
 * @hidden
 */
export var createLink = function (linkAttrs) { return function (state, dispatch) {
    if (isMarkActive(state, schema.marks.link)) {
        modifyMark(schema.marks.link, linkAttrs)(state, dispatch);
    }
    else {
        toggleMark(schema.marks.link, linkAttrs)(state, dispatch);
    }
}; };
/**
 * @hidden
 */
export var applyHeading = function (level) { return setBlockType(heading, { level: level }); };
/**
 * @hidden
 */
export var applyParagraph = setBlockType(paragraph);
/**
 * @hidden
 */
export var applyBlockquote = setBlockType(blockquote);
/**
 * @hidden
 */
export var format = function (_a) {
    var tag = _a.tag;
    if (tag.match(/h\d\b/)) {
        return applyHeading(parseInt(tag[1], 10));
    }
    else if (tag === 'p') {
        return applyParagraph;
    }
    else if (tag === 'blockquote') {
        return applyBlockquote;
    }
};
/**
 * @hidden
 */
export var indent = sinkListItem(listItem);
/**
 * @hidden
 */
export var outdent = liftListItem(listItem);
/**
 * @hidden
 */
export var insertImage = function (attrs) { return function (state, dispatch) {
    var node = image.createAndFill(attrs);
    dispatch(state.tr.replaceSelectionWith(node));
}; };
/**
 * @hidden
 */
export var getHTML = function (state) {
    var fragment = DOMSerializer
        .fromSchema(state.schema)
        .serializeFragment(state.doc.content);
    var element = document.createElement('div');
    element.appendChild(fragment);
    return element.innerHTML;
};
/**
 * @hidden
 */
export var createContentNode = function (value) {
    var element = document.createElement('div');
    // when using ngModel with name attr, content is null and errors, default params dont help
    element.innerHTML = safeString(value).trim();
    return DOMParser.fromSchema(schema).parse(element);
};
/**
 * @hidden
 */
export var setHTML = function (content) { return function (state, dispatch) {
    return dispatch(state.tr
        .setSelection(new AllSelection(state.doc))
        .replaceSelectionWith(createContentNode(content)));
}; };
/**
 * @hidden
 */
export var hasSameMarkup = function (dom1, dom2) {
    var fragment1 = Fragment.from(createContentNode(dom1));
    var fragment2 = Fragment.from(createContentNode(dom2));
    return fragment1.eq(fragment2);
};
/**
 * @hidden
 */
var blockNodes = function (state) {
    var selection = state.selection;
    var from = selection.from, to = selection.to, $from = selection.$from;
    var result = [];
    if (selection.node) {
        if (selection.node.isBlock) {
            result.push(selection.node);
        }
        else if ($from.parent && $from.parent.isBlock) {
            result.push($from.parent);
        }
    }
    else {
        state.doc.nodesBetween(from, to, function (node) {
            if (node.isBlock) {
                result.push(node);
            }
        });
    }
    return result;
};
/**
 * @hidden
 */
var changeStyles = function (elementStyle, newStyle) {
    var styleToChange = newStyle.style;
    var regExp = newStyle.value;
    var newValue = newStyle.newValue;
    var styleMatches = [];
    if (elementStyle) {
        var splits = elementStyle.split(/\s*;\s*/).filter(function (s) { return s; });
        var filtered = splits.filter(function (s) {
            if (!s.toLowerCase().trim().startsWith(styleToChange)) {
                return true;
            }
            var value = s.split(':')[1].trim();
            if (regExp.test(value)) {
                styleMatches.push(value);
                return false;
            }
            return true;
        });
        if (newValue) {
            filtered.push(styleToChange + ": " + newValue);
        }
        return {
            style: filtered.join('; ') + (filtered.length ? ';' : ''),
            changed: !!newValue || filtered.length !== splits.length,
            styleMatches: styleMatches
        };
    }
    return { changed: false, styleMatches: styleMatches, style: null };
};
/**
 * @hidden
 */
var addStyles = function (node, stylesToApply) {
    var currentStyles = node.attrs.style, changedStyleResult = null, toChange = null;
    if (currentStyles) {
        stylesToApply.forEach(function (style) {
            toChange = { style: style.name, value: /^.+$/, newValue: style.value };
            changedStyleResult = changeStyles(currentStyles, toChange);
            currentStyles = changedStyleResult.changed ? changedStyleResult.style : currentStyles;
        });
    }
    var reducer = function (acc, curr) {
        return (acc && curr.value ? acc + ' ' : '') + curr.value ? curr.name + ": " + curr.value + ";" : '';
    };
    currentStyles = currentStyles ||
        stylesToApply.reduce(reducer, '');
    return Object.assign({}, node.attrs, { style: currentStyles || null });
};
/**
 * @hidden
 */
var canChangeType = function (stateDoc, pos, type) {
    var $pos = stateDoc.resolve(pos), index = $pos.index();
    return $pos.parent.canReplaceWith(index, index + 1, type);
};
/**
 * @hidden
 */
var changeBlockNode = function (state, dispatch, tr, node, nodeType, attrs) {
    var _a = state.selection, from = _a.from, to = _a.to;
    var applicable = false;
    state.doc.nodesBetween(from, to, function (currNode, pos) {
        if (applicable) {
            return false;
        }
        if (!currNode.isTextblock || currNode.hasMarkup(nodeType, attrs)) {
            return;
        }
        if (currNode.type === nodeType) {
            applicable = true;
        }
        else {
            var $pos = state.doc.resolve(pos), index = $pos.index();
            applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
    });
    if (!applicable) {
        return false;
    }
    if (dispatch) {
        // const tr = view.state.tr;
        // const tr = view.state.tr.setBlockType(from, to, nodeType, attrs);
        if (!nodeType.isTextblock) {
            throw new RangeError('Type given to setBlockType should be a textblock');
        }
        var mapFrom_1 = tr.steps.length;
        tr.doc.nodesBetween(from, to, function (currNode, pos) {
            if (currNode.eq(node) && currNode.isTextblock && !currNode.hasMarkup(nodeType, attrs) &&
                canChangeType(tr.doc, tr.mapping.slice(mapFrom_1).map(pos), nodeType)) {
                // Ensure all markup that isn't allowed in the new node type is cleared
                tr.clearIncompatible(tr.mapping.slice(mapFrom_1).map(pos, 1), nodeType);
                var mapping = tr.mapping.slice(mapFrom_1);
                var startM = mapping.map(pos, 1), endM = mapping.map(pos + currNode.nodeSize, 1);
                var slice = new Slice(Fragment.from(nodeType.create(attrs, null, currNode.marks)), 0, 0);
                tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, slice, 1, true));
                return false; // this will skip the node children
            }
        });
        // view.dispatch(tr.scrollIntoView());
    }
    return true;
};
/**
 * @hidden
 * Aligning block elements in the selection.
 *
 * @returns {boolean} - Returns true if any alignment is applied.
 */
export var alignBlocks = function (actions) { return function (state, dispatch) {
    var blocks = blockNodes(state);
    var tr = state.tr;
    var result = false;
    blocks.forEach(function (node) {
        if (node.type.isTextblock) {
            var newAttrs = {};
            var action = actions.find(function (n) { return n.node === node.type.name; });
            if (action) {
                newAttrs = addStyles(node, action.style);
            }
            result = changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
}; };
/**
 * @hidden
 * Checks if any block element in the selection is aligned.
 */
export var isAligned = function (state, actions) {
    var blocks = blockNodes(state);
    var result = false;
    blocks.forEach(function (node) {
        if (!result && node.type.isTextblock && node.attrs.style) {
            var action = actions.find(function (a) { return a.node === node.type.name; });
            if (action) {
                result = action.style.every(function (style) {
                    return !!style.value && new RegExp(style.name + ":\\s?" + style.value, 'i').test(node.attrs.style);
                });
            }
        }
    });
    return result;
};
