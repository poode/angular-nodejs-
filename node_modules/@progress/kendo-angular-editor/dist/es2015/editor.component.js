import { Component, HostBinding, ViewChild, ContentChild, ViewContainerRef, Output, ElementRef, EventEmitter, forwardRef, Input } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { fromEvent } from 'rxjs/observable/fromEvent';
import { map } from 'rxjs/operators/map';
import { filter } from 'rxjs/operators/filter';
import { ToolBarComponent } from '@progress/kendo-angular-toolbar';
import { DialogService } from '@progress/kendo-angular-dialog';
import { EditorView } from 'prosemirror-view';
import { baseKeymap } from 'prosemirror-commands';
import { EditorState } from 'prosemirror-state';
import { keymap } from 'prosemirror-keymap';
import { history, undo, redo } from 'prosemirror-history';
import { schema } from './config/schema';
import { buildKeymap } from './config/keymap';
import { editorCommands } from './config/commands';
import { alignRightRules, alignCenterRules, alignRemoveRules, alignLeftRules } from './config/align-rules';
import { LinkDialogComponent } from './dialogs/link-dialog.component';
import { SourceDialogComponent } from './dialogs/source-dialog.component';
import { ImageDialogComponent } from './dialogs/image-dialog.component';
import { isMarkActive, activeNodeName, canIndent, canOutdent, getHTML, createContentNode, hasSameMarkup, isInListOfType, isAligned } from './prosemirror-utils';
function updateToolBar({ state }) {
    return {
        //marks
        bold: isMarkActive(state, schema.marks.strong),
        italic: isMarkActive(state, schema.marks.em),
        underline: isMarkActive(state, schema.marks.underline),
        strikethrough: isMarkActive(state, schema.marks.strikethrough),
        link: isMarkActive(state, schema.marks.link),
        subscript: isMarkActive(state, schema.marks.subscript),
        superscript: isMarkActive(state, schema.marks.superscript),
        //nodes
        format: activeNodeName(state),
        insertOrderedList: isInListOfType(state, schema.nodes.orderedList),
        insertUnorderedList: isInListOfType(state, schema.nodes.bulletList),
        indent: canIndent(state, schema.nodes.listItem),
        outdent: canOutdent(state, schema.nodes.listItem),
        alignLeft: isAligned(state, alignLeftRules),
        alignCenter: isAligned(state, alignCenterRules),
        alignRight: isAligned(state, alignRightRules),
        alignJustify: isAligned(state, alignRemoveRules),
        //history
        undo: !undo(state),
        redo: !redo(state),
        //selection
        noSelection: state.selection.empty
    };
}
const editorDialogs = {
    createLink: {
        content: LinkDialogComponent
    },
    viewSource: {
        content: SourceDialogComponent,
        width: 500,
        height: 400
    },
    insertImage: {
        content: ImageDialogComponent
    }
};
const EMPTY_PARAGRAPH = '<p></p>';
/**
 * Represents the [Kendo UI Editor component for Angular]({% slug overview_editor %}).
 */
export class EditorComponent {
    constructor(element, dialogService) {
        this.element = element;
        this.dialogService = dialogService;
        /**
         * Fires each time the value of the Editor is changed upon user interaction&mdash;
         * for example, when the component is blurred or the value is updated through the `viewSource` dialog.
         * When the value of the Editor is programmatically changed through its API (`ngModel`) or form binding (`formControl`),
         * the `valueChange` event is not triggered because it might cause a mix-up with the
         * built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.stateChange = new EventEmitter();
        this.onChangeCallback = (_) => { }; // tslint:disable-line:no-empty
        this.onTouchedCallback = (_) => { }; // tslint:disable-line:no-empty
    }
    /**
     * Sets the value of the Editor ([see example]({% slug overview_editor %}#toc-basic-usage)).
     */
    set value(value) {
        this._value = value;
        this._previousValue = value;
        if (this.view) {
            this.exec('setHTML', this._value);
        }
    }
    get value() {
        let value = this.view ? this.getSource() : this._value;
        if (value === EMPTY_PARAGRAPH) {
            return this._value ? '' : this._value;
        }
        else {
            return value;
        }
    }
    get className() {
        return 'k-widget k-editor';
    }
    ngAfterViewInit() {
        const that = this;
        const containerNativeElement = this.container.element.nativeElement;
        const contentNode = createContentNode(this.value);
        const state = EditorState.create({
            schema: schema,
            doc: contentNode,
            plugins: [
                history(),
                keymap(buildKeymap(schema)),
                keymap({
                    'Mod-z': undo,
                    'Mod-y': redo
                }),
                keymap(baseKeymap)
            ]
        });
        this.view = new EditorView(containerNativeElement, {
            state,
            dispatchTransaction: function (tr) {
                // `this` is bound to the view instance.
                this.updateState(this.state.apply(tr));
                that.stateChange.emit(updateToolBar(this));
                // When the user utilizes keyboard shortcuts&mdash;for example, `Ctrl`+`b`&mdash;
                // `tr.docChanged` is `true` and the toolbar is not updated.
                // A possible future solution is to move the keymaps to the service.
                // if (!tr.docChanged) {
                //     that.stateChange.emit(updateToolBar(that.view));
                // }
            }
        });
        this.subs = fromEvent(this.container.element.nativeElement, 'keyup').pipe(map((e) => e.keyCode), filter((code) => code === 121), // F10
        map(() => this.userToolBar || this.defaultToolbar))
            .subscribe((toolbar) => toolbar.nativeElement.focus());
        const blur$ = fromEvent(this.element.nativeElement, 'focusout').pipe(filter((event) => !this.element.nativeElement.contains(event.relatedTarget)));
        this.subs.add(
        //on blur & new value
        blur$.pipe(map(() => this.value), filter((value) => !hasSameMarkup(value, that._previousValue)))
            .subscribe((value) => {
            this._previousValue = value;
            this.onChangeCallback(value);
            this.valueChange.emit(value);
        }));
        this.subs.add(
        //on every blur
        blur$.subscribe(() => this.onTouchedCallback()));
    }
    /**
     * Executes a command on the currently selected text.
     *
     * @param {EditorCommand} commandName - The command that will be executed.
     * @param {any} attr - Optional parameters for the command. Apart from the following list, the parameters do not expect specific attributes when you call them:
     * - `format` - Accepts an object with the `tag` property.
     * The supported tags are `p`, `blockquote`, and any of the `h1` to `h6` heading tags.
     * - `createLink` - Accepts an object with the `href`, `title`, and `target` properties. The `href` property is mandatory.
     * - `setHTML` - Accepts a `string` parameter.
     *
     * @example
     * ```ts-no-run
     * // Toggles the bold styling.
     * editor.exec('bold');
     *
     * // Creates a bullet list.
     * editor.exec('insertUnorderedList');
     *
     * // Creates a link.
     * editor.exec('createLink', { href: 'www.progress.com', title: 'Progress', target: 'window' });
     *
     * // Changes the format of a text block.
     * editor.exec('format', { tag: 'h2' });
     *
     * // Changes the content of the Editor.
     * editor.exec('setHTML', '<p>HTML content</p>');
     * ```
     */
    exec(commandName, attr) {
        // Finds a command and applies the attributes.
        const command = editorCommands[commandName](attr);
        // Executes a ProseMirror command.
        command(this.view.state, this.view.dispatch, this.view);
        // See the `dispatchTransaction` comments.
        // this.stateChange.emit(updateToolBar(this.view));
    }
    /**
     * Opens a dialog.
     * @param {DialogCommand} dialogName - The name of the dialog that will open.
     *
     * The supported values are:
     * * `createLink`
     * * `viewSource`
     *
     * @example
     * ```ts-no-run
     * // Opens a `createLink` dialog.
     * editor.openDialog('createLink');
     *
     * // Opens a `viewSource` dialog.
     * editor.exec('viewSource');
     * ```
     */
    openDialog(dialogName) {
        const dialog = editorDialogs[dialogName];
        const dialogRef = this.dialogService.open(dialog);
        dialogRef.content.instance.editor = this;
        dialogRef.content.instance.setData(this.view.state);
    }
    /**
     * Manually focus the Editor.
     */
    focus() {
        this.view.focus();
    }
    /**
     * Manually blur the Editor.
     */
    blur() {
        this.view.dom.blur();
    }
    /**
     * @hidden
     */
    getSource() {
        return getHTML(this.view.state);
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    /**
     * @hidden
     */
    writeValue(value) {
        // To avoid confusion, non-existent values are always undefined.
        this.value = value === null ? undefined : value;
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
}
EditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'kendo-editor',
                providers: [
                    DialogService,
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => EditorComponent),
                        multi: true
                    }
                ],
                template: `
        <ng-content select="kendo-toolbar"></ng-content>
        <kendo-toolbar *ngIf="!userToolBar" #defaultToolbar>
            <kendo-toolbar-buttongroup>
                <kendo-toolbar-button kendoEditorButton="bold"></kendo-toolbar-button>
                <kendo-toolbar-button kendoEditorButton="italic"></kendo-toolbar-button>
                <kendo-toolbar-button kendoEditorButton="underline"></kendo-toolbar-button>
            </kendo-toolbar-buttongroup>
            <kendo-toolbar-dropdownlist kendoEditorDropDown="format"></kendo-toolbar-dropdownlist>
            <kendo-toolbar-buttongroup>
                <kendo-toolbar-button kendoEditorButton="insertUnorderedList"></kendo-toolbar-button>
                <kendo-toolbar-button kendoEditorButton="insertOrderedList"></kendo-toolbar-button>
            </kendo-toolbar-buttongroup>
            <!-- <kendo-toolbar-dialog kendoEditorCommand="createLink"></kendo-toolbar-dialog> -->
        </kendo-toolbar>
        <div #content class="k-content" style="height: 300px;"></div>
        <div kendoDialogContainer></div>
    `,
                styles: [`
        >>> .k-content > .ProseMirror {
            height: 100%;
            width: 100%;
            box-sizing: border-box;
            outline: none;
            overflow: scroll;
        }
    `]
            },] },
];
/** @nocollapse */
EditorComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DialogService, },
];
EditorComponent.propDecorators = {
    'value': [{ type: Input },],
    'valueChange': [{ type: Output },],
    'className': [{ type: HostBinding, args: ['class',] },],
    'userToolBar': [{ type: ContentChild, args: [ToolBarComponent, { read: ElementRef },] },],
    'container': [{ type: ViewChild, args: ['content', { read: ViewContainerRef },] },],
    'defaultToolbar': [{ type: ViewChild, args: ['defaultToolbar', { read: ElementRef },] },],
};
