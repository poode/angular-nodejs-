import { Schema } from 'prosemirror-model';
import { isEmpty, serializeDOMAttrs, removeEmptyEntries, removeEntries } from '../util';
const SLOT = 0; //https://prosemirror.net/docs/guide/#schema.serialization_and_parsing
const commonAttributes = () => {
    return {
        style: { default: null },
        class: { default: null },
        id: { default: null }
    };
};
/**
 * @hidden
 */
const marks = {
    // TODO: Add target.
    // :: MarkSpec A link. Has `href` and `title` attributes. `title`
    // defaults to an empty string. Rendered and parsed as an `<a>`
    // element.
    link: {
        attrs: {
            href: { default: '' },
            title: { default: null }
        },
        inclusive: false,
        parseDOM: [{
                tag: 'a[href]',
                getAttrs: (dom) => ({
                    href: dom.getAttribute('href'),
                    title: dom.getAttribute('title')
                })
            }],
        toDOM: (mark) => [
            'a',
            // Add default value for href. Otherwise the link is not rendered properly(blue with underline)
            Object.assign({}, { href: '' }, removeEmptyEntries(mark.attrs)),
            SLOT
        ]
    },
    // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.
    // Has parse rules that also match `<i>` and `font-style: italic`.
    em: {
        parseDOM: [
            { tag: 'i' },
            { tag: 'em' },
            { style: 'font-style=italic' }
        ],
        toDOM: () => ['em', SLOT]
    },
    // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules
    // also match `<b>` and `font-weight: bold`.
    strong: {
        parseDOM: [
            { tag: 'strong' },
            // This works around a Google Docs misbehavior where
            // pasted content will be inexplicably wrapped in `<b>`
            // tags with a font-weight normal `{tag: 'b', getAttrs: node => node.style.fontWeight != 'normal' && null}`,
            {
                style: 'font-weight',
                // According to the docs, the value can be a DOM element (for tag rules) or a string (for style rules).
                getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
            }
        ],
        toDOM: () => ['strong', SLOT]
    },
    // :: MarkSpec Code font mark. Represented as a `<code>` element.
    code: {
        parseDOM: [{ tag: 'code' }],
        toDOM: () => ['code', SLOT]
    },
    // :: MarkSpec An underline mark. Rendered as a `<u>` element.
    // Parse rules also match `text-decoration: underline`.
    underline: {
        parseDOM: [
            { tag: 'u' },
            { style: 'text-decoration=underline' }
        ],
        toDOM: () => ['u', SLOT]
    },
    // :: MarkSpec A strikethrough mark. Rendered as a `<del>` element.
    // Parse rules also match `<s>`, `<strike>`, `text-decoration: line-through`.
    strikethrough: {
        parseDOM: [
            { tag: 'del' },
            { tag: 's' },
            { tag: 'strike' },
            { style: 'text-decoration=line-through' }
        ],
        toDOM: () => ['del', SLOT]
    },
    // :: MarkSpec A subscript mark. Rendered as a `<sub>` element.
    // Parse rules also match `vertical-align: sub`.
    subscript: {
        parseDOM: [
            { tag: 'sub' },
            { style: 'vertical-align=sub' }
        ],
        toDOM: () => ['sub', SLOT]
    },
    // :: MarkSpec A superscript mark. Rendered as a `<sup>` element.
    // Parse rules also match `vertical-align: super`.
    superscript: {
        parseDOM: [
            { tag: 'sup' },
            { style: 'vertical-align=super' }
        ],
        toDOM: () => ['sup', SLOT]
    }
};
/**
 * @hidden
 */
const nodes = {
    // :: NodeSpec The top level document node.
    doc: {
        content: 'block+'
    },
    // :: NodeSpec A plain textblock paragraph. Represented
    // as a `<p>` element in the DOM.
    paragraph: {
        content: 'inline*',
        group: 'block',
        attrs: Object.assign({}, commonAttributes()),
        parseDOM: [{
                tag: 'p',
                getAttrs: serializeDOMAttrs
            }],
        toDOM: (node) => isEmpty(node.attrs) ? ['p', SLOT] : ['p', removeEmptyEntries(node.attrs), SLOT]
    },
    // :: NodeSpec A blockquote (`<blockquote>`) which wraps one or more blocks.
    blockquote: {
        content: 'inline*',
        group: 'block',
        attrs: Object.assign({}, commonAttributes()),
        defining: true,
        parseDOM: [{ tag: 'blockquote' }],
        toDOM: (node) => ['blockquote', removeEmptyEntries(node.attrs), SLOT]
    },
    // :: NodeSpec A horizontal (`<hr>`) rule.
    horizontalRule: {
        group: 'block',
        parseDOM: [{ tag: 'hr' }],
        toDOM: () => ['hr']
    },
    // :: NodeSpec A heading textblock with a `level` attribute that
    // has to hold a number from 1 to 6. Parsed and serialized as an `<h1>` to
    // an `<h6>` element.
    heading: {
        attrs: Object.assign({ level: { default: 1 } }, commonAttributes()),
        content: 'inline*',
        group: 'block',
        defining: true,
        parseDOM: [
            { tag: 'h1', attrs: { level: 1 } },
            { tag: 'h2', attrs: { level: 2 } },
            { tag: 'h3', attrs: { level: 3 } },
            { tag: 'h4', attrs: { level: 4 } },
            { tag: 'h5', attrs: { level: 5 } },
            { tag: 'h6', attrs: { level: 6 } }
        ],
        toDOM: (node) => {
            const attrs = removeEntries(node.attrs, (key) => key !== 'level');
            return ['h' + node.attrs.level, removeEmptyEntries(attrs), SLOT];
        }
    },
    // :: NodeSpec A code listing. Prevents marks or non-text inline
    // nodes by default. Represented as a `<pre>` element with a
    // `<code>` element inside.
    codeBlock: {
        content: 'text*',
        marks: '',
        group: 'block',
        code: true,
        defining: true,
        parseDOM: [{
                tag: 'pre',
                preserveWhitespace: 'full'
            }],
        toDOM: () => ['pre', ['code', SLOT]]
    },
    // :: NodeSpec The text node.
    text: {
        group: 'inline'
    },
    // :: NodeSpec An inline image (`<img>`) node. Supports `src`,
    // `alt`, and `href` attributes. The last two default to an empty
    // string.
    image: {
        inline: true,
        attrs: Object.assign({}, commonAttributes(), { src: {}, alt: { default: null }, width: { default: null }, height: { default: null } }),
        group: 'inline',
        draggable: true,
        parseDOM: [{
                tag: 'img[src]',
                getAttrs: (dom) => ({
                    src: dom.getAttribute('src'),
                    alt: dom.getAttribute('alt'),
                    width: dom.getAttribute('width'),
                    height: dom.getAttribute('height')
                })
            }],
        toDOM: (node) => ['img', removeEmptyEntries(node.attrs)]
    },
    // :: NodeSpec A hard line break. Represented as a `<br>` element in the DOM.
    hardBreak: {
        inline: true,
        group: 'inline',
        selectable: false,
        parseDOM: [{ tag: 'br' }],
        toDOM: () => ['br']
    },
    // :: NodeSpec A list item. Represented as a `<li>` element.
    listItem: {
        attrs: Object.assign({}, commonAttributes()),
        content: 'paragraph block*',
        marks: '_',
        parseDOM: [{ tag: 'li' }],
        toDOM: (node) => ['li', removeEmptyEntries(node.attrs), SLOT]
    },
    // :: NodeSpec An ordered list. Represented as an `<ol>` element.
    // Has a single `order` attribute which determines the number at which
    // the list starts counting. Defaults to 1.
    orderedList: {
        attrs: {
            order: {
                default: 1
            }
        },
        content: 'listItem+',
        group: 'block',
        parseDOM: [{
                tag: 'ol',
                getAttrs: (dom) => ({
                    order: dom.hasAttribute('start') ? parseInt(dom.getAttribute('start'), 10) : 1
                })
            }],
        toDOM: node => (node.attrs.order === 1 ? ['ol', SLOT] : ['ol', { start: node.attrs.order }, SLOT])
    },
    // :: NodeSec An unordered list. Represented as a `<ul>` element.
    bulletList: {
        content: 'listItem+',
        group: 'block',
        parseDOM: [{ tag: 'ul' }],
        toDOM: () => ['ul', SLOT]
    }
};
/**
 * @hidden
 */
export const schema = new Schema({
    nodes,
    marks
});
