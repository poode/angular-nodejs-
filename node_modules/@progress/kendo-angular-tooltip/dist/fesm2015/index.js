import { Component, Directive, ElementRef, EventEmitter, HostBinding, Inject, Injectable, InjectionToken, Input, NgModule, NgZone, Optional, Output, Renderer2, isDevMode } from '@angular/core';
import { take as take$1 } from 'rxjs/operators/take';
import { fromEvent as fromEvent$1 } from 'rxjs/observable/fromEvent';
import { debounceTime as debounceTime$1 } from 'rxjs/operators/debounceTime';
import { filter as filter$1 } from 'rxjs/operators/filter';
import { PopupModule, PopupService } from '@progress/kendo-angular-popup';
import { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';
import { CommonModule } from '@angular/common';

/**
 * Obsolete. Provide the TooltipSettings class instead.
 *
 * @hidden
 */
const TOOLTIP_SETTINGS = new InjectionToken('kendo-ui-tooltip-settings');
/**
 * Provides a global configuration for the Kendo UI Tooltip. Once injected through
 * the `AppComponent` constructor, the configuration properties can be overridden.
 *
 * @example
 * ```ts-no-run
 * import { TooltipSettings } from '@progress/kendo-angular-tooltip';
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *      <div kendoTooltip>
 *          <button title="Saves the current document">Save</button>
 *      </div>`,
 *    providers: [{
 *        provide: TooltipSettings,
 *        useFactory: (): TooltipSettings => ({
 *          // Override default values of tooltips if wanted
 *          position: 'right'
 *        })
 *    }]
 * })
 * export class AppComponent { }
 * ```
 */
class TooltipSettings {
}
TooltipSettings.decorators = [
    { type: Injectable },
];
/** @nocollapse */
TooltipSettings.ctorParameters = () => [];

/**
 * @hidden
 */
function align(position, offset) {
    let anchorAlign = {};
    let popupAlign = {};
    let popupMargin = {};
    switch (position) {
        case 'top':
            anchorAlign = { horizontal: 'center', vertical: 'top' };
            popupAlign = { horizontal: 'center', vertical: 'bottom' };
            popupMargin = { horizontal: 0, vertical: offset };
            break;
        case 'bottom':
            anchorAlign = { horizontal: 'center', vertical: 'bottom' };
            popupAlign = { horizontal: 'center', vertical: 'top' };
            popupMargin = { horizontal: 0, vertical: offset };
            break;
        case 'right':
            anchorAlign = { horizontal: 'right', vertical: 'center' };
            popupAlign = { horizontal: 'left', vertical: 'center' };
            popupMargin = { horizontal: offset, vertical: 0 };
            break;
        case 'left':
            anchorAlign = { horizontal: 'left', vertical: 'center' };
            popupAlign = { horizontal: 'right', vertical: 'center' };
            popupMargin = { horizontal: offset, vertical: 0 };
            break;
        default: break;
    }
    return {
        anchorAlign,
        popupAlign,
        popupMargin
    };
}
/**
 * @hidden
 */
function collision(inputcollision, position) {
    if (inputcollision) {
        return inputcollision;
    }
    if (position === 'top' || position === 'bottom') {
        return { horizontal: 'fit', vertical: 'flip' };
    }
    return { horizontal: 'flip', vertical: 'fit' };
}
function isDocumentNode(container) {
    return container.nodeType === 9;
}
/**
 * @hidden
 */
function closest(element, selector) {
    if (element.closest) {
        return element.closest(selector);
    }
    const matches = Element.prototype.matches ?
        (el, sel) => el.matches(sel)
        : (el, sel) => el.msMatchesSelector(sel);
    let node = element;
    while (node && !isDocumentNode(node)) {
        if (matches(node, selector)) {
            return node;
        }
        node = node.parentNode;
    }
}
/**
 * @hidden
 */
function contains(container, child) {
    if (!container) {
        return false;
    }
    if (isDocumentNode(container)) {
        return false;
    }
    if (container.contains) {
        return container.contains(child);
    }
    if (container.compareDocumentPosition) {
        // tslint:disable-next-line
        return !!(container.compareDocumentPosition(child) & Node.DOCUMENT_POSITION_CONTAINED_BY);
    }
}
/**
 * @hidden
 */
const hasParent = (node, parent) => {
    while (node && node !== parent) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
function getCenterOffset(item, dir, size) {
    const rect = item.getBoundingClientRect();
    return rect[dir] + (rect[size] / 2);
}
/**
 * @hidden
 */
function containsItem(collection, item) {
    return collection.indexOf(item) !== -1;
}

/**
 * @hidden
 */
class TooltipContentComponent {
    constructor(content) {
        this.content = content;
        this.close = new EventEmitter();
        this.tooltipWidth = null;
        this.tooltipHeight = null;
        this.callout = true;
        this.calloutStyles = (position, calloutSize, isFlip) => {
            const styles = {};
            const isVertical = position === 'top' || position === 'bottom';
            const flipDeg = '180deg';
            const zeroDeg = '0deg';
            if (!isFlip) {
                styles.transform = isVertical ? `rotateX(${zeroDeg})` : `rotateY(${zeroDeg})`;
                return styles;
            }
            if (position === 'top') {
                styles.bottom = 'unset';
            }
            else if (position === 'bottom') {
                styles.top = 'unset';
            }
            else if (position === 'left') {
                styles.right = 'unset';
            }
            else if (position === 'right') {
                styles.left = 'unset';
            }
            styles[position] = `${-calloutSize}px`;
            styles.transform = isVertical ? `rotateX(${flipDeg})` : `rotateY(${flipDeg})`;
            return styles;
        };
    }
    get cssClasses() {
        return 'k-widget k-tooltip';
    }
    get className() {
        return this.closable;
    }
    get cssPosition() {
        return 'relative';
    }
    calloutPositionClass() {
        return {
            'top': 'k-callout-s',
            'left': 'k-callout-e',
            'bottom': 'k-callout-n',
            'right': 'k-callout-w'
        }[this.position];
    }
    onCloseClick(event) {
        event.preventDefault();
        this.close.emit();
    }
    updateCalloutPosition(position, isFlip) {
        const isVertical = position === 'top' || position === 'bottom';
        const size = isVertical ? 'width' : 'height';
        const dir = isVertical ? 'left' : 'top';
        const offsetProperty = isVertical ? 'marginLeft' : 'marginTop';
        const callout = this.content.nativeElement.querySelector('.k-callout');
        if (!callout) {
            return;
        }
        const calloutSize = callout.getBoundingClientRect()[size];
        const anchorCenter = getCenterOffset(this.anchor.nativeElement, dir, size);
        const contentCenter = getCenterOffset(this.content.nativeElement, dir, size);
        const diff = Math.abs(contentCenter - anchorCenter);
        if (diff > 1 || diff === 0) {
            const newMargin = contentCenter - anchorCenter + (calloutSize / 2);
            callout.style[offsetProperty] = `${-newMargin}px`;
        }
        const calloutStyles = this.calloutStyles(position, calloutSize, isFlip);
        Object.keys(calloutStyles).forEach((style) => {
            callout.style[style] = calloutStyles[style];
        });
    }
}
TooltipContentComponent.decorators = [
    { type: Component, args: [{
                template: `
        <div class="k-tooltip-title" *ngIf="titleTemplate">
            <ng-template
                [ngIf]="titleTemplate"
                [ngTemplateOutlet]="titleTemplate"
                [ngTemplateOutletContext]="{ $implicit: anchor, anchor: anchor }">
            </ng-template>
        </div>
        <div *ngIf="closable" class="k-tooltip-button" (click)="onCloseClick($event)">
            <a href="#" class="k-icon k-i-close" title="Close"></a>
        </div>

        <div class="k-tooltip-content">
            <ng-template
                [ngIf]="templateRef"
                [ngTemplateOutlet]="templateRef"
                [ngTemplateOutletContext]="{ $implicit: anchor, anchor: anchor }">
            </ng-template>
            <ng-template
                [ngIf]="templateString">
                {{ templateString }}
            </ng-template>
        </div>
        <div class="k-callout" *ngIf="callout" [ngClass]="calloutPositionClass()"></div>
    `
            },] },
];
/** @nocollapse */
TooltipContentComponent.ctorParameters = () => [
    { type: ElementRef, },
];
TooltipContentComponent.propDecorators = {
    'close': [{ type: Output },],
    'cssClasses': [{ type: HostBinding, args: ['class',] },],
    'className': [{ type: HostBinding, args: ['class.k-tooltip-closable',] },],
    'cssPosition': [{ type: HostBinding, args: ['style.position',] },],
    'tooltipWidth': [{ type: HostBinding, args: ['style.width.px',] }, { type: Input },],
    'tooltipHeight': [{ type: HostBinding, args: ['style.height.px',] }, { type: Input },],
    'titleTemplate': [{ type: Input },],
    'anchor': [{ type: Input },],
    'closable': [{ type: Input },],
    'templateRef': [{ type: Input },],
    'templateString': [{ type: Input },],
};

/**
 * Represents the [Kendo UI Tooltip directive for Angular]({% slug overview_tooltip %}).
 * Used to display additional information that is related to an element.
 *
 * @example
 * ```ts-no-run
 * <div kendoTooltip>
 *    <a title="Tooltip title" href="foo">foo</a>
 * </div>
 * ```
 */
class TooltipDirective {
    constructor(tooltipWrapper, ngZone, renderer, popupService, localizationService, settings, legacySettings) {
        this.tooltipWrapper = tooltipWrapper;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.popupService = popupService;
        this.localizationService = localizationService;
        /**
         * Specifies a selector for elements within a container which will display a tooltip
         * ([see example]({% slug anchorelements_tooltip %})). The possible values include any
         * DOM `selector`. The default value is `[title]`.
         */
        this.filter = '[title]';
        /**
         * Specifies the position of the Tooltip that is relative to the
         * anchor element ([see example]({% slug positioning_tooltip %})).
         *
         * The possible values are:
         * * `top` (default)
         * * `bottom`
         * * `left`
         * * `right`
         */
        this.position = 'top';
        /**
         * Specifies the delay in milliseconds before the Tooltip is shown.
         * * `100` (default) milliseconds.
         */
        this.showAfter = 100;
        /**
         * Specifies if the Тooltip will display a callout arrow.
         *
         * The possible values are:
         * * `true` (default)
         * * `false`
         */
        this.callout = true;
        /**
         * Specifies if the Тooltip will display a **Close** button
         * ([see example]({% slug closable_tooltip %})).
         *
         * The possible values are:
         * * `true`
         * * `false`
         */
        this.closable = false;
        /**
         * Specifies the offset in pixels between the Tooltip and the anchor. Defaults to `6` pixels.
         * If the `callout` property is set to `true`, the offset is rendered from the callout arrow.
         * If the `callout` property is set to `false`, the offset is rendered from the content of the Tooltip.
         */
        this.offset = 6;
        this.anchor = null;
        this.validPositions = ['top', 'bottom', 'right', 'left'];
        this.validShowOptions = ['hover', 'click', 'none'];
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
        Object.assign(this, settings, legacySettings);
        this.ngZone.runOutsideAngular(() => {
            const wrapper = this.tooltipWrapper.nativeElement;
            this.anchorTitleSubscription = fromEvent$1(wrapper, 'mouseover')
                .pipe(filter$1(() => this.filter !== ''))
                .subscribe((e) => {
                const filterElement = closest(e.target, this.filter);
                if (filterElement) {
                    this.hideElementTitle({ nativeElement: filterElement });
                }
            });
            this.mouseOverSubscription = fromEvent$1(wrapper, 'mouseover')
                .pipe(debounceTime$1(100), filter$1(() => this.filter !== ''))
                .subscribe(e => this.onMouseOver(e));
            this.mouseOutSubscription = fromEvent$1(wrapper, 'mouseout')
                .pipe(debounceTime$1(100))
                .subscribe(e => this.onMouseOut(e));
        });
    }
    /**
     * Sets the content of the Tooltip as a template reference
     * ([see example]({% slug templates_tooltip %})).
     */
    set tooltipTemplate(value) {
        this.template = value;
    }
    get tooltipTemplate() { return this.template; }
    /**
     * Shows the Tooltip.
     * @param anchor&mdash; ElementRef|Element.
     * Specifies the element that will be used as an anchor. The Tooltip opens relative to that element.
     */
    show(anchor) {
        if (this.popupRef) {
            return;
        }
        if (anchor instanceof Element) {
            anchor = { nativeElement: anchor };
        }
        this.anchor = anchor;
        if (this.showOn === 'hover') {
            if (this.popupRef) {
                return;
            }
            clearTimeout(this.showTimeout);
            this.showTimeout = window.setTimeout(() => this.showContent(this.anchor), this.showAfter);
        }
        else {
            this.hideElementTitle(this.anchor);
            this.showContent(this.anchor);
        }
    }
    /**
     * Hides the Tooltip.
     */
    hide() {
        clearTimeout(this.showTimeout);
        const anchor = this.anchor && this.anchor.nativeElement;
        if (anchor && anchor.getAttribute('data-title')) {
            if (!anchor.getAttribute('title')) {
                anchor.setAttribute('title', anchor.getAttribute('data-title'));
            }
            anchor.setAttribute('data-title', '');
        }
        if (this.popupMouseOutSubscription) {
            this.popupMouseOutSubscription.unsubscribe();
        }
        if (this.closeClickSubscription) {
            this.closeClickSubscription.unsubscribe();
        }
        this.closePopup();
    }
    /**
     * Toggle visibility of the Tooltip.
     *
     * @param anchor&mdash; ElementRef|Element. Specifies the element that will be used as an anchor.
     * @param show&mdash; Optional. Boolean. Specifies if the Tooltip will be rendered.
     */
    toggle(anchor, show) {
        const previousAnchor = this.anchor && this.anchor.nativeElement;
        if (anchor instanceof Element) {
            anchor = { nativeElement: anchor };
        }
        if (previousAnchor !== anchor.nativeElement) {
            this.hide();
        }
        if (previousAnchor === anchor.nativeElement && this.showOn === 'click') {
            this.hide();
        }
        if (typeof show === 'undefined') {
            show = !this.popupRef;
        }
        if (show) {
            this.show(anchor);
        }
        else {
            this.hide();
        }
    }
    ngOnInit() {
        if (this.showOn === undefined) {
            this.showOn = 'hover';
        }
        this.verifyProperties();
        this.dynamicRTLSubscription = this.localizationService.changes
            .subscribe(({ rtl }) => this.direction = rtl ? 'rtl' : 'ltr');
    }
    ngOnChanges(changes) {
        if (changes.showOn) {
            this.subscribeClick();
        }
    }
    ngAfterViewChecked() {
        if (!this.popupRef) {
            return;
        }
        if (this.anchor &&
            !hasParent(this.anchor.nativeElement || this.anchor, this.tooltipWrapper.nativeElement)) {
            this.anchor = null;
            this.hide();
        }
    }
    ngOnDestroy() {
        this.hide();
        this.template = null;
        this.anchorTitleSubscription.unsubscribe();
        this.mouseOverSubscription.unsubscribe();
        this.mouseOutSubscription.unsubscribe();
        if (this.mouseClickSubscription) {
            this.mouseClickSubscription.unsubscribe();
        }
        if (this.dynamicRTLSubscription) {
            this.dynamicRTLSubscription.unsubscribe();
        }
        if (this.popupPositionChangeSubscription) {
            this.popupPositionChangeSubscription.unsubscribe();
        }
        if (this.popupMouseOutSubscription) {
            this.popupMouseOutSubscription.unsubscribe();
        }
    }
    showContent(anchorRef) {
        if (!anchorRef.nativeElement.getAttribute('data-title') && !this.template) {
            return;
        }
        this.ngZone.run(() => {
            this.openPopup(anchorRef);
            this.bindContent(this.popupRef.content, anchorRef);
        });
        this.popupRef.popupAnchorViewportLeave
            .pipe(take$1(1))
            .subscribe(() => this.hide());
    }
    bindContent(contentComponent, anchorRef) {
        const content = contentComponent.instance;
        this.closeClickSubscription = content.close
            .subscribe(() => { this.hide(); });
        if (!this.template) {
            content.templateString = this.anchor.nativeElement.getAttribute('data-title');
        }
        else {
            content.templateRef = this.template;
        }
        if (this.titleTemplate) {
            content.titleTemplate = this.titleTemplate;
        }
        content.anchor = anchorRef;
        content.callout = this.callout;
        content.closable = this.closable;
        content.position = this.position;
        content.tooltipWidth = this.tooltipWidth;
        content.tooltipHeight = this.tooltipHeight;
        this.popupRef.content.changeDetectorRef.detectChanges();
    }
    hideElementTitle(elementRef) {
        const element = elementRef.nativeElement;
        if (element.getAttribute('title')) {
            element.setAttribute('data-title', element.getAttribute('title'));
            element.setAttribute('title', '');
        }
    }
    openPopup(anchorRef) {
        const alignSettings = align(this.position, this.offset);
        const anchorAlign = alignSettings.anchorAlign;
        const popupAlign = alignSettings.popupAlign;
        const popupMargin = alignSettings.popupMargin;
        this.popupRef = this.popupService.open({
            anchor: anchorRef,
            anchorAlign,
            animate: false,
            content: TooltipContentComponent,
            collision: collision(this.collision, this.position),
            margin: popupMargin,
            popupAlign,
            popupClass: 'k-popup-transparent'
        });
        this.renderer.addClass(this.popupRef.popupElement, 'k-tooltip-wrapper');
        if (this.tooltipClass) {
            this.renderer.addClass(this.popupRef.popupElement, this.tooltipClass);
        }
        const popupInstance = this.popupRef.content.instance;
        if (popupInstance.callout) {
            this.popupPositionChangeSubscription = this.popupRef.popupPositionChange
                .subscribe(({ flip }) => {
                const isFlip = flip.horizontal === true || flip.vertical === true;
                popupInstance.updateCalloutPosition(this.position, isFlip);
            });
        }
        if (this.showOn === 'hover') {
            this.ngZone.runOutsideAngular(() => {
                const popup = this.popupRef.popupElement;
                this.popupMouseOutSubscription = fromEvent$1(popup, 'mouseout')
                    .subscribe((e) => this.onMouseOut(e));
            });
        }
    }
    closePopup() {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
        if (this.popupPositionChangeSubscription) {
            this.popupPositionChangeSubscription.unsubscribe();
        }
    }
    subscribeClick() {
        if (this.mouseClickSubscription) {
            this.mouseClickSubscription.unsubscribe();
        }
        if (this.showOn === 'click') {
            this.mouseClickSubscription = fromEvent$1(document, 'click')
                .pipe(filter$1(() => this.filter !== ''))
                .subscribe(e => this.onMouseClick(e, this.tooltipWrapper.nativeElement));
        }
    }
    onMouseClick(e, wrapper) {
        const target = e.target;
        const filterElement = closest(target, this.filter);
        const popup = this.popupRef && this.popupRef.popupElement;
        if (popup) {
            if (popup.contains(target)) {
                return;
            }
            if (this.closable) {
                return;
            }
        }
        if (wrapper.contains(target) && filterElement) {
            this.toggle(filterElement, true);
        }
        else if (popup) {
            this.hide();
        }
    }
    onMouseOver(e) {
        const filterElement = closest(e.target, this.filter);
        if (this.showOn !== 'hover') {
            return;
        }
        if (filterElement) {
            this.toggle(filterElement, true);
        }
    }
    onMouseOut(e) {
        if (this.showOn !== 'hover') {
            return;
        }
        if (this.closable) {
            return;
        }
        const popup = this.popupRef && this.popupRef.popupElement;
        const relatedTarget = e.relatedTarget;
        if (relatedTarget && this.anchor && contains(this.anchor.nativeElement, relatedTarget)) {
            return;
        }
        if (relatedTarget && contains(popup, relatedTarget)) {
            return;
        }
        this.hide();
    }
    verifyProperties() {
        if (!isDevMode()) {
            return;
        }
        if (!containsItem(this.validPositions, this.position)) {
            throw new Error(`Invalid value provided for position property.The available options are 'top', 'bottom', 'left', or 'right'.`);
        }
        if (!containsItem(this.validShowOptions, this.showOn)) {
            throw new Error(`Invalid value provided for showOn property.The available options are 'hover' or 'none'.`);
        }
    }
}
TooltipDirective.decorators = [
    { type: Directive, args: [{
                selector: '[kendoTooltip]',
                exportAs: 'kendoTooltip',
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.tooltip'
                    }
                ]
            },] },
];
/** @nocollapse */
TooltipDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: NgZone, },
    { type: Renderer2, },
    { type: PopupService, },
    { type: LocalizationService, },
    { type: TooltipSettings, decorators: [{ type: Optional },] },
    { type: TooltipSettings, decorators: [{ type: Optional }, { type: Inject, args: [TOOLTIP_SETTINGS,] },] },
];
TooltipDirective.propDecorators = {
    'direction': [{ type: HostBinding, args: ['attr.dir',] },],
    'filter': [{ type: Input },],
    'position': [{ type: Input },],
    'titleTemplate': [{ type: Input },],
    'showOn': [{ type: Input },],
    'showAfter': [{ type: Input },],
    'callout': [{ type: Input },],
    'closable': [{ type: Input },],
    'offset': [{ type: Input },],
    'tooltipWidth': [{ type: Input },],
    'tooltipHeight': [{ type: Input },],
    'tooltipClass': [{ type: Input },],
    'collision': [{ type: Input },],
    'tooltipTemplate': [{ type: Input },],
};

const COMPONENT_DIRECTIVES = [TooltipDirective, TooltipContentComponent];
const COMPONENT_MODULES = [PopupModule];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Tooltip component.
 *
 * The package exports:
 * - `KendoTooltipDirective`&mdash;The Tooltip directive class.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Tooltip module
 * import { TooltipModule } from '@progress/kendo-angular-tooltip';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * _@NgModule{{
 *    declarations: [AppComponent], // declare app component
 *    imports:      [BrowserModule, TooltipModule], // import TooltipModule module
 *    bootstrap:    [AppComponent]
 * }}
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 * ```
 */
class TooltipModule {
}
TooltipModule.decorators = [
    { type: NgModule, args: [{
                declarations: [COMPONENT_DIRECTIVES],
                entryComponents: [TooltipContentComponent],
                imports: [CommonModule, ...COMPONENT_MODULES],
                exports: [COMPONENT_DIRECTIVES]
            },] },
];
/** @nocollapse */
TooltipModule.ctorParameters = () => [];

/**
 * Generated bundle index. Do not edit.
 */

export { TooltipContentComponent, TooltipDirective, TooltipModule, TooltipSettings, TOOLTIP_SETTINGS };
