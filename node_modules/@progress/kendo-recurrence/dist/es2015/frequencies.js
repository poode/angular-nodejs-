import { MS_PER_DAY, MS_PER_HOUR } from '@progress/kendo-date-math';
import * as limitations from './limitations';
import { setDayOfWeek } from './utils';
const RULE_NAMES = ["months", "weeks", "yearDays", "monthDays", "weekDays", "hours", "minutes", "seconds"];
const RULE_NAMES_LENGTH = RULE_NAMES.length;
const intervalExcess = (diff, interval) => {
    var excess;
    if (diff !== 0 && diff < interval) {
        excess = interval - diff;
    }
    else {
        excess = diff % interval;
        if (excess) {
            excess = interval - excess;
        }
    }
    return excess;
};
const addTime = (date, time) => {
    date.setTime(date.getTime() + time);
};
//TODO: move to util as it is used in limitaions too
const normalizeDayIndex = (weekDay, weekStart) => {
    return weekDay + (weekDay < weekStart ? 7 : 0);
};
/** @hidden */
export class BaseFrequency {
    next(date, rule) {
        var startTime = rule._startTime, minutes, seconds;
        if (rule.seconds) {
            seconds = date.getUTCSeconds() + 1;
            date.setUTCSeconds(seconds);
            startTime.setUTCSeconds(seconds);
        }
        else if (rule.minutes) {
            minutes = date.getUTCMinutes() + 1;
            date.setUTCMinutes(minutes);
            startTime.setUTCMinutes(minutes);
        }
        else {
            return false;
        }
        return true;
    }
    normalize(options) {
        var rule = options.rule;
        if (options.idx === 4 && rule.hours) {
            rule._startTime.setUTCHours(0);
            this._hour(options.date, rule);
        }
    }
    limit(date, end, rule) {
        var interval = rule.interval || 1, ruleName, firstRule, modified, idx, day;
        while (date <= end) {
            modified = firstRule = undefined;
            day = date.getUTCDate();
            for (idx = 0; idx < RULE_NAMES_LENGTH; idx++) {
                ruleName = RULE_NAMES[idx];
                if (rule[ruleName]) {
                    modified = limitations[ruleName](date, end, rule);
                    if (firstRule !== undefined && modified) {
                        break;
                    }
                    else {
                        firstRule = modified;
                    }
                }
                if (modified) {
                    this.normalize({ date: date, rule: rule, day: day, idx: idx });
                }
            }
            if ((interval === 1 || !this.interval(rule, date)) && idx === RULE_NAMES_LENGTH) {
                break;
            }
        }
    }
    interval(rule, current) {
        var start = rule._startPeriod.toUTCDate();
        var date = new Date(current);
        var hours = current.getUTCHours();
        var weekStart = rule.weekStart;
        var interval = rule.interval;
        var frequency = rule.freq;
        var modified = false;
        var excess = 0;
        var month = 0;
        var day = 1;
        var diff;
        var startTimeHours;
        if (frequency === "hourly") {
            startTimeHours = rule._startTime.getUTCHours();
            date = date.getTime();
            if (hours !== startTimeHours) {
                date += (startTimeHours - hours) * MS_PER_HOUR;
            }
            date -= start.getTime();
            diff = Math.floor(date / MS_PER_HOUR);
            excess = intervalExcess(diff, interval);
            if (excess !== 0) {
                this._hour(current, rule, excess);
                modified = true;
            }
        }
        else if (frequency === "daily") {
            addTime(date, -start);
            diff = Math.round(date / MS_PER_DAY);
            excess = intervalExcess(diff, interval);
            if (excess !== 0) {
                this._date(current, rule, excess);
                modified = true;
            }
        }
        else if (frequency === "weekly") {
            excess = this.getNumberOfWeeksBetweenDates(start, current);
            var normalizedCurrentIndex = normalizeDayIndex(current.getUTCDay(), weekStart);
            var normalizedStartIndex = normalizeDayIndex(start.getUTCDay(), weekStart);
            if (normalizedCurrentIndex < normalizedStartIndex) {
                excess += 1;
            }
            excess = intervalExcess(excess, interval);
            if (excess !== 0) {
                setDayOfWeek(current, rule.weekStart, -1);
                current.setUTCDate(current.getUTCDate() + (excess * 7));
                modified = true;
            }
        }
        else if (frequency === "monthly") {
            diff = current.getUTCFullYear() - start.getUTCFullYear();
            diff = current.getUTCMonth() - start.getUTCMonth() + (diff * 12);
            excess = intervalExcess(diff, interval);
            if (excess !== 0) {
                // TODO: Investigate _hasRuleValue
                // day = rule._hasRuleValue ? 1 : current.getDate();
                day = current.getUTCDate();
                current.setUTCFullYear(current.getUTCFullYear(), current.getUTCMonth() + excess, day);
                modified = true;
            }
        }
        else if (frequency === "yearly") {
            diff = current.getUTCFullYear() - start.getUTCFullYear();
            excess = intervalExcess(diff, interval);
            if (!rule.months) {
                month = current.getUTCMonth();
            }
            if (!rule.yearDays && !rule.monthDays && !rule.weekDays) {
                day = current.getUTCDate();
            }
            if (excess !== 0) {
                current.setUTCFullYear(current.getUTCFullYear() + excess, month, day);
                modified = true;
            }
        }
        return modified;
    }
    _hour(date, rule, interval) {
        var startTime = rule._startTime, hours = startTime.getUTCHours();
        if (interval) {
            hours += interval;
        }
        date.setUTCHours(hours);
        hours = hours % 24;
        startTime.setUTCHours(hours);
    }
    _date(date, rule, interval) {
        date.setUTCDate(date.getUTCDate() + interval);
    }
    getNumberOfWeeksBetweenDates(first, second) {
        var weeks = (second.getTime() - first.getTime()) / 604800000;
        var exactWeeks = Math.floor(weeks);
        //this is happening when weeks pass DST change
        if (weeks - exactWeeks > 0.99) {
            exactWeeks = Math.round(weeks);
        }
        return exactWeeks;
    }
}
/** @hidden */
export class HourlyFrequency extends BaseFrequency {
    next(date, rule) {
        if (!BaseFrequency.prototype.next.call(this, date, rule)) {
            this._hour(date, rule, 1);
        }
        return false;
    }
    normalize(options) {
        var rule = options.rule;
        if (options.idx === 4) {
            rule._startTime.setUTCHours(0);
            this._hour(options.date, rule);
        }
    }
}
/** @hidden */
export class DailyFrequency extends BaseFrequency {
    next(date, rule) {
        if (!BaseFrequency.prototype.next.call(this, date, rule)) {
            this[rule.hours ? "_hour" : "_date"](date, rule, 1);
        }
        return false;
    }
}
/** @hidden */
export class WeeklyFrequency extends DailyFrequency {
    setup(rule, eventStartDate) {
        if (!rule.weekDays) {
            rule.weekDays = [{
                    day: eventStartDate.getUTCDay(),
                    offset: 0
                }];
        }
    }
}
/** @hidden */
export class MonthlyFrequency extends BaseFrequency {
    next(date, rule) {
        var day;
        if (!BaseFrequency.prototype.next.call(this, date, rule)) {
            if (rule.hours) {
                this._hour(date, rule, 1);
            }
            else if (rule.monthDays || rule.weekDays || rule.yearDays || rule.weeks) {
                this._date(date, rule, 1);
            }
            else {
                day = date.getUTCDate();
                date.setUTCMonth(date.getUTCMonth() + 1);
                while (date.getUTCDate() !== day) {
                    date.setUTCDate(day);
                }
                this._hour(date, rule);
            }
        }
        return false;
    }
    normalize(options) {
        var rule = options.rule, date = options.date;
        if (options.idx === 0 && !rule.monthDays && !rule.weekDays) {
            date.setUTCDate(options.day);
        }
        else {
            super.normalize(options);
        }
    }
    setup(rule, eventStartDate, date) {
        if (!rule.monthDays && !rule.weekDays) {
            date.setUTCDate(eventStartDate.getUTCDate());
        }
    }
}
/** @hidden */
export class YearlyFrequency extends MonthlyFrequency {
    next(date, rule) {
        var day;
        if (!BaseFrequency.prototype.next.call(this, date, rule)) {
            if (rule.hours) {
                this._hour(date, rule, 1);
            }
            else if (rule.monthDays || rule.weekDays || rule.yearDays || rule.weeks) {
                this._date(date, rule, 1);
            }
            else if (rule.months) {
                day = date.getUTCDate();
                date.setUTCMonth(date.getUTCMonth() + 1);
                while (date.getUTCDate() !== day) {
                    date.setUTCDate(day);
                }
                this._hour(date, rule);
            }
            else {
                date.setUTCFullYear(date.getUTCFullYear() + 1);
                this._hour(date, rule);
            }
        }
        return false;
    }
    setup() {
        // No-op
    }
}
