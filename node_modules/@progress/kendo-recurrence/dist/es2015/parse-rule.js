import { parseArray, parseDateTime, parseDateTimeList, parseISODate, parseWeekDayList, parseWeekDay } from './utils';
const normalizeWeekDay = (day, weekStart) => (day + (day < weekStart ? 7 : 0));
const weekDaysSortPredicate = (weekStart) => (a, b) => (normalizeWeekDay(a.day, weekStart) - normalizeWeekDay(b.day, weekStart));
const sortWeekDays = (rrule) => {
    const { weekDays, weekStart } = rrule;
    if (!weekDays) {
        return;
    }
    weekDays.sort(weekDaysSortPredicate(weekStart));
};
/**
 * @hidden
 *
 * Internal method for parsing of iCal recurrence rule string.
 */
export const parseRule = (options) => {
    if (!options) {
        return null;
    }
    const { recurrenceRule, weekStart = 0 } = options;
    const rrule = {};
    let splits, value;
    let idx = 0, length;
    let hasModifiers = false;
    let rule, part, parts;
    let property;
    if (!recurrenceRule) {
        return null;
    }
    parts = recurrenceRule.split("\n");
    if (!parts[1] && (recurrenceRule.indexOf("DTSTART") !== -1 ||
        recurrenceRule.indexOf("DTEND") !== -1 ||
        recurrenceRule.indexOf("EXDATE") !== -1)) {
        parts = recurrenceRule.split(" ");
    }
    for (idx = 0, length = parts.length; idx < length; idx++) {
        part = (parts[idx] || '').trim();
        if (part.indexOf("DTSTART") !== -1) {
            rrule.start = parseDateTime(part);
        }
        else if (part.indexOf("DTEND") !== -1) {
            rrule.end = parseDateTime(part);
        }
        else if (part.indexOf("EXDATE") !== -1) {
            rrule.exceptionDates = parseDateTimeList(part);
        }
        else if (part.indexOf("RRULE") !== -1) {
            rule = part.substring(6);
        }
        else if (part.trim()) {
            rule = part;
        }
    }
    rule = rule.split(";");
    for (idx = 0, length = rule.length; idx < length; idx++) {
        property = rule[idx];
        splits = property.split("=");
        value = (splits[1] || '').trim().split(",");
        switch (splits[0].trim().toUpperCase()) {
            case "FREQ":
                rrule.freq = value[0].toLowerCase();
                break;
            case "UNTIL":
                rrule.until = parseISODate(value[0]);
                break;
            case "COUNT":
                rrule.count = parseInt(value[0], 10);
                break;
            case "INTERVAL":
                rrule.interval = parseInt(value[0], 10);
                break;
            case "BYSECOND":
                rrule.seconds = parseArray(value, { start: 0, end: 60 });
                hasModifiers = true;
                break;
            case "BYMINUTE":
                rrule.minutes = parseArray(value, { start: 0, end: 59 });
                hasModifiers = true;
                break;
            case "BYHOUR":
                rrule.hours = parseArray(value, { start: 0, end: 23 });
                hasModifiers = true;
                break;
            case "BYMONTHDAY":
                rrule.monthDays = parseArray(value, { start: -31, end: 31 });
                hasModifiers = true;
                break;
            case "BYYEARDAY":
                rrule.yearDays = parseArray(value, { start: -366, end: 366 });
                hasModifiers = true;
                break;
            case "BYMONTH":
                rrule.months = parseArray(value, { start: 1, end: 12 });
                hasModifiers = true;
                break;
            case "BYDAY":
                rrule.weekDays = parseWeekDayList(value);
                hasModifiers = true;
                break;
            case "BYWEEKNO":
                rrule.weeks = parseArray(value, { start: -53, end: 53 });
                hasModifiers = true;
                break;
            case "BYSETPOS":
                rrule.positions = parseArray(value, { start: -366, end: 366 });
                break;
            case "WKST":
                rrule.weekStart = parseWeekDay(value[0]);
                break;
            default:
                break;
        }
    }
    if (rrule.freq === undefined || (rrule.count !== undefined && rrule.until)) {
        return null;
    }
    if (rrule.weekStart === undefined) {
        rrule.weekStart = weekStart;
    }
    if (!rrule.interval) {
        rrule.interval = 1;
    }
    if (rrule.positions && !hasModifiers) {
        rrule.positions = [];
    }
    sortWeekDays(rrule);
    return rrule;
};
